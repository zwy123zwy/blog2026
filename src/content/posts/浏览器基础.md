---
title: 浏览器基础
published: 2026-02-15
description: ''
image: ''
tags: []
category: ''
draft: false 
lang: ''
---

# 浏览器

## 进程与线程

从本质上说，进程和线程都是 CPU 工作时间片的一个描述：

* 进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。
* 线程是进程中的更小单位，描述了执行一段指令所需的时间。

进程是资源分配的最小单位，线程是CPU调度的最小单位。

进程和线程的区别

* 进程可以看做独立应用，线程不能
* 资源：
  **进程是cpu资源分配的最小单位**（是能拥有资源和独立运行的最小单位）；
  **线程是cpu调度的最小单位**（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
* 通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。
* 调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
* 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

**进程是运行在虚拟内存上的**，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。

**如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存**。

**进程和线程之间的关系有以下四个特点：**

**（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。**

**（2）线程之间共享进程中的数据。**

**（3）当一个进程关闭之后，操作系统会回收进程所占用的内存**。当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。

**（4）进程之间的内容相互隔离**进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。

### 死锁

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。

系统中的资源可以分为两类：

* 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
* 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。

**产生死锁的原因：**

**（1）竞争资源**

* **产生死锁中的竞争资源之一指的是**竞争不可剥夺资源**（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
* **产生死锁中的竞争资源另外一种资源指的是**竞争临时资源**（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁

**（2）进程间推进顺序非法**

**若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁**

**产生死锁的必要条件：**

* **互斥条件**：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
* **请求和保持条件**：当进程因请求资源而阻塞时，对已获得的资源保持不放。
* **不剥夺条件**：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
* **环路等待条件**：在发生死锁时，必然存在一个进程——资源的环形链。

**预防死锁的方法：**

* 资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）
* 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）
* 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
* 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

**孤儿进程**：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

**僵尸进程**：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程

### 进程之间的通信方式

**（1）管道通信**

**管道是一种最基本的进程间通信机制。**管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。

**管道的特点：**

* **只能单向通信**
* **只能血缘关系的进程进行通信**
* **依赖于文件系统**
* **生命周期随进程**
* **面向字节流的服务**
* **管道内部提供了同步机制**

**（2）消息队列通信**

**消息队列就是一个消息的列表**。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。

使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。

**（3）信号量通信**

共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。

**（4）信号通信**

信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。

**（5）共享内存通信**

共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

**（6）套接字通信**

上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。

## **Chrome浏览器的架构图**：

![img](./img/21994.jpg)

**从图中可以看出，最新的 Chrome 浏览器包括：**

* 1 个浏览器主进程
* 1 个 GPU 进程
* 1 个网络进程
* 多个渲染进程
* 多个插件进程

**这些进程的功能：**

* **浏览器进程**：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
* **渲染进程**：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
* **GPU 进程**：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
* **网络进程**：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
* **插件进程**：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

**所以，**打开一个网页，最少需要四个进程**：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

**虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：**

* **更高的资源占用**：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
* **更复杂的体系架构**：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

### 浏览器渲染进程的线程有哪些

**浏览器的渲染进程的线程总共有五种：**

![img](./img/19964.jpg)

**（1）GUI渲染线程**

**负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要**重绘**或由于某种操作引发**回流**时，该线程就会执行。

**浏览器渲染主要有以下步骤：**

* 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。
* 然后对 CSS 进行解析，生成 CSSOM 规则树。
* 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。
* 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
* 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

**大致过程如图所示：**

![img](./img/1810.jpg)

**注意**：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

**注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。**

#### 浏览器渲染优化

**  （1）针对JavaScript：JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：**

1. 尽量将JavaScript文件放在body的最后
2. body中间尽量不要写﻿script标签
3. script标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：
   ● script **立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面**；
   ● async 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序
   ● defer 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。

（2）针对CSS：使用CSS有三种方式：使用link、@import、内联样式

**其中link和@import都是导入外部样式。它们之间的区别：**

* **link：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码**
* **@import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)**
* **style：GUI直接渲染**

外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。

以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。

（3）针对DOM树、CSSOM树：
可以通过以下几种方式来减少渲染的时间：
● HTML文件的代码层级尽量不要太深
● 使用语义化的标签，来避免不标准语义化的特殊处理
● 减少CSS代码的层级，因为选择器是从左向右进行解析的

（4）减少回流与重绘：
● 操作DOM时，尽量在低层级的DOM节点进行操作
● 不要使用﻿table﻿布局， 一个小的改动可能会使整个﻿table﻿进行重新布局
● 使用CSS的表达式**
● 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。

● 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素
● 避免频繁操作DOM，可以创建一个文档片段﻿documentFragment﻿，在它上面应用所有DOM操作，最后再把它添加到文档中
● 将元素先设置﻿display: none﻿，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
● 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制

浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列

浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。

** 将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。

#### 渲染过程中遇到 JS 文件如何处理？

JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。

#### 什么是文档的预解析？

Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。

#### **CSS 如何阻塞文档解析？**

理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。

#### 如何优化关键渲染路径？

为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素
（1）关键资源的数量。
（2）关键路径长度。
（3）关键字节的数量。

关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。

化关键渲染路径的常规步骤如下：
（1）对关键路径进行分析和特性描述：资源数、字节数、长度。
（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。
3）优化关键字节数以缩短下载时间（往返次数）。
4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度

#### 什么情况会阻塞渲染？

首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。

**当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async **属性**。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。**

**（2）JS引擎线程**

JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；

![](./img/deepseek_mermaid_20250628_8a7e0d.png)

#### 详细步骤说明（以V8引擎为例）

1. **解析（Parsing）阶段**

* **词法分析（Lexical Analysis）**：

  * **将源代码分解为**令牌（Tokens）**
  * **示例：**`const sum = (a, b) => a + b;` →**
    **`[const, sum, =, (, a, ,, b, ), =>, a, +, b, ;]`

* **语法分析（Syntax Analysis）**：

  * **根据ECMAScript规范构建**抽象语法树（AST）**

  * **工具：Esprima、Acorn**

  * **示例AST结构：**

    <pre class=" CodeMirror-line " role="presentation"><span role="presentation">{</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-string cm-property">"type"</span>: <span class="cm-string">"Program"</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-string cm-property">"body"</span>: [{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-string cm-property">"type"</span>: <span class="cm-string">"VariableDeclaration"</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-string cm-property">"declarations"</span>: [{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">      <span class="cm-string cm-property">"type"</span>: <span class="cm-string">"VariableDeclarator"</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">      <span class="cm-string cm-property">"id"</span>: { <span class="cm-string cm-property">"type"</span>: <span class="cm-string">"Identifier"</span>, <span class="cm-string cm-property">"name"</span>: <span class="cm-string">"sum"</span> },</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">      <span class="cm-string cm-property">"init"</span>: {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">        <span class="cm-string cm-property">"type"</span>: <span class="cm-string">"ArrowFunctionExpression"</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">        <span class="cm-string cm-property">"params"</span>: [<span class="cm-meta">...</span>],</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">        <span class="cm-string">"body"</span>: { <span class="cm-meta">...</span> }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">      }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    }]</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  }]</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">}</span></pre></div></div></div></div></div><div></div></div></div></pre>

2. **预编译阶段**

* **关键处理**：
  * **函数声明和变量提升**
  * **创建词法环境（Lexical Environment）**
  * **建立作用域链（Scope Chain）**
  * **闭包预处理**

3. **编译阶段**

**a) **解释器路径（Ignition）**

* **将AST转换为**字节码（Bytecode）**

* **字节码示例：**

  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="text" cid="n1854" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="text"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">LdaNamedProperty a0, [0]</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Add a1, [1]</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Return</span></pre></div></div></div></div></div><div></div></div></div></pre>

* **优点：快速启动，跨平台**

**b) **优化编译器路径（TurboFan）**

* **监控热点函数（多次执行的代码）**
* **生成高度优化的**机器码**
* **优化技术：**
  * **内联缓存（Inline Caches）**
  * **隐藏类（Hidden Classes）**
  * **类型反馈（Type Feedback）**

4. **执行阶段**

* **执行上下文（Execution Context）**：

  * **包含：**
    * **变量环境（VariableEnvironment）**
    * **词法环境（LexicalEnvironment）**
    * **this绑定**

* **调用栈管理**：

  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="js" cid="n1890" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><span><span></span></span></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">function</span> <span class="cm-def">first</span>() { <span class="cm-variable">second</span>(); }</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">function</span> <span class="cm-def">second</span>() { <span class="cm-variable">third</span>(); }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">function</span> <span class="cm-def">third</span>() { <span class="cm-variable">console</span>.<span class="cm-property">trace</span>(); }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">first</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 调用栈：</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// third</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// second</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// first</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// (anonymous)</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

5. **优化与反优化**

* **优化条件**：

  * **函数被多次调用（通常 > 10次）**
  * **参数类型稳定**

* **反优化场景**：

  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="js" cid="n1904" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">function</span> <span class="cm-def">add</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>; }</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 优化路径（数字）</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">add</span>(<span class="cm-number">1</span>, <span class="cm-number">2</span>); <span class="cm-comment">// 类型：Number</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">add</span>(<span class="cm-number">3</span>, <span class="cm-number">4</span>); <span class="cm-comment">// 仍为Number → 保持优化</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 反优化路径</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">add</span>(<span class="cm-string">"5"</span>, <span class="cm-string">"6"</span>); <span class="cm-comment">// 类型变为String → 丢弃机器码</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

6. **内存管理**

* **垃圾回收策略**：
  * **新生代（New Space）**：Scavenge算法（复制）
  * **老生代（Old Space）**：标记-清除（Mark-Sweep） + 标记-整理（Mark-Compact）
* **回收时机**：
  * **内存分配失败时**
  * **定时执行（增量标记）**

**注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。**

**（3）事件触发线程**

**事件触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；**

![](./img/deepseek_mermaid_20250628_9843a9.png)

**注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；**

**（4）定时器触发进程**

**定时器触发进程**即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；

**注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。**

**（5）异步http请求线程**

* **XMLHttpRequest连接后通过浏览器新开一个线程请求；**
* **检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；**

### **浏览器输入url后的时序图**

![img](./img/26826.jpg)

## 浏览器事件机制

### 事件是什么？事件模型？

**事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。**

**事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：**

* **DOM0 级事件模型**，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。
* **IE 事件模型**，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。
* **DOM2 级事件模型**，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。

### 如何阻止事件冒泡

* **普通浏览器使用：event.stopPropagation() **
* **IE浏览器使用：event.cancelBubble = true;**

### 对事件委托的理解

**（1）事件委托的概念**

**事件委托本质上是利用了**浏览器事件冒泡**的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。

**使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。**

**（2）事件委托的特点**

* **减少内存消耗**

**如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：**

<pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tag cm-bracket"><</span><span class="cm-tag">ul</span> <span class="cm-attribute">id</span>=<span class="cm-string">"list"</span><span class="cm-tag cm-bracket">></span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-tag cm-bracket"><</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span>item 1<span class="cm-tag cm-bracket"></</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-tag cm-bracket"><</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span>item 2<span class="cm-tag cm-bracket"></</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-tag cm-bracket"><</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span>item 3<span class="cm-tag cm-bracket"></</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  ......</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-tag cm-bracket"><</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span>item n<span class="cm-tag cm-bracket"></</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tag cm-bracket"></</span><span class="cm-tag">ul</span><span class="cm-tag cm-bracket">></span></span></pre></div></div></div></div></div><div></div></div></div></pre>

**如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。**

* **动态绑定事件**

**给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="javascript" cid="n1978" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="javascript"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 给父层元素绑定事件</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">document</span>.<span class="cm-property">getElementById</span>(<span class="cm-string">'list'</span>).<span class="cm-property">addEventListener</span>(<span class="cm-string">'click'</span>, <span class="cm-keyword">function</span> (<span class="cm-def">e</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-comment">// 兼容性处理</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-keyword">var</span> <span class="cm-def">event</span> <span class="cm-operator">=</span> <span class="cm-variable-2">e</span> <span class="cm-operator">||</span> <span class="cm-variable">window</span>.<span class="cm-property">event</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-keyword">var</span> <span class="cm-def">target</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">target</span> <span class="cm-operator">||</span> <span class="cm-variable-2">event</span>.<span class="cm-property">srcElement</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-comment">// 判断是否匹配目标元素</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-keyword">if</span> (<span class="cm-variable-2">target</span>.<span class="cm-property">nodeName</span>.<span class="cm-property">toLocaleLowerCase</span> <span class="cm-operator">===</span> <span class="cm-string">'li'</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">'the content is: '</span>, <span class="cm-variable-2">target</span>.<span class="cm-property">innerHTML</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">});</span></pre></div></div></div></div></div><div></div></div></div></pre>

**在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；**

**（3）局限性**

**当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。**

**当然事件委托不是只有优点，它也是有**缺点**的，事件委托会影响页面性能，主要影响因素有：

* **元素中，绑定事件委托的次数；**
* **点击的最底层元素，到绑定事件元素之间的** `DOM`层数；

**在必须使用事件委托的地方，可以进行如下的处理：**

* **只在必须的地方，使用事件委托，比如：**`ajax`的局部刷新区域
* **尽量的减少绑定的层级，不在** `body`元素上，进行绑定
* **减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。**

### 事件委托的使用场景

**场景：给页面的所有的a标签添加click事件，代码如下：**

<div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">document</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">e</span>) {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-keyword">if</span> (<span class="cm-variable-2">e</span>.<span class="cm-property">target</span>.<span class="cm-property">nodeName</span> <span class="cm-operator">==</span> <span class="cm-string">"A"</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"a"</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">}, <span class="cm-atom">false</span>);</span></pre></div></div></div></div></div><div></div></div></div></pre>

**但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。**

**这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="javascript" cid="n2005" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="javascript"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">document</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">e</span>) {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-keyword">var</span> <span class="cm-def">node</span> <span class="cm-operator">=</span> <span class="cm-variable-2">e</span>.<span class="cm-property">target</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-keyword">while</span> (<span class="cm-variable-2">node</span>.<span class="cm-property">parentNode</span>.<span class="cm-property">nodeName</span> <span class="cm-operator">!=</span> <span class="cm-string">"BODY"</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-keyword">if</span> (<span class="cm-variable-2">node</span>.<span class="cm-property">nodeName</span> <span class="cm-operator">==</span> <span class="cm-string">"A"</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"a"</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-keyword">break</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span>}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-variable-2">node</span> <span class="cm-operator">=</span> <span class="cm-variable-2">node</span>.<span class="cm-property">parentNode</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span>}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">}, <span class="cm-atom">false</span>);</span></pre></div></div></div></div></div><div></div></div></div></pre>

### 同步和异步的区别

* **同步**指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。
* **异步**指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理

### 事件触发的过程是怎样的

**事件触发有三个阶段：**

**●window 往事件触发处传播，遇到注册的捕获事件会触发**

**●传播到事件触发处时触发注册的事件**

**●从事件触发处往 window 传播，遇到注册的冒泡事件会触发**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="js" cid="n2017" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 以下会先打印冒泡然后是捕获</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">node</span>.<span class="cm-property">addEventListener</span>(</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-string">'click'</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-def">event</span> <span class="cm-operator">=></span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">'冒泡'</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  },</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-atom">false</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">node</span>.<span class="cm-property">addEventListener</span>(</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-string">'click'</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-def">event</span> <span class="cm-operator">=></span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">'捕获 '</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  },</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-atom">true</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">)</span></pre></div></div></div></div></div><div></div></div></div></pre>

**事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。**

**通常使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false ，useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：**

**●capture：布尔值，和 useCapture 作用一样**

**●once：布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听**

**●passive：布尔值，表示永远不会调用 preventDefault**

**一般来说，如果只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。**

**stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="js" cid="n2028" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">node</span>.<span class="cm-property">addEventListener</span>(</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-string">'click'</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-def">event</span> <span class="cm-operator">=></span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable-2">event</span>.<span class="cm-property">stopImmediatePropagation</span>()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">'冒泡'</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  },</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-atom">false</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">node</span>.<span class="cm-property">addEventListener</span>(</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-string">'click'</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-def">event</span> <span class="cm-operator">=></span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">'捕获 '</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  },</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-atom">true</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">)</span></pre></div></div></div></div></div><div></div></div></div></pre>

## 浏览器缓存

### 对浏览器的缓存机制的理解

**浏览器缓存的全过程：**

* **浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；**
* **下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；**
* **如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；**
* **服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；**
* **如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；**

![img](./img/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE1.png)

**很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。**

### 协商缓存和强缓存的区别

#### （1）强缓存

**使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。**

**强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 **Expires 属性**和 **Cache-Control 属性**。

**（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。**这个时间是一个绝对时间，它是服务器的时间**，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

**（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，**

`Cache-Control`可设置的字段：

* `public`：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；
* `private`：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；
* `no-cache`：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；
* `no-store`：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；
* `max-age=`：设置缓存的最大有效期，**单位为秒**；
* `s-maxage=`：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；
* `max-stale[=]`：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。

**一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。**

**no-cache和no-store很容易混淆：**

* **no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；**
* **no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。**

#### （2）协商缓存

**如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。**

**上面已经说到了，命中协商缓存的条件有两个：**

* `max-age=xxx` 过期了
* **值为** `no-store`

**使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。**

**协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 **Etag** 和 **Last-Modified** 属性。

（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。

（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。

当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。

**总结：**

强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

### 为什么需要浏览器缓存？

对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求认为的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。

**所谓的**浏览器缓存**指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。

**使用浏览器缓存，有以下优点：**

* **减少了服务器的负担，提高了网站的性能**
* **加快了客户端网页的加载速度**
* **减少了多余网络数据传输**

### 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？

* **点击刷新按钮或者按 F5：**浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。
* **用户按 Ctrl+F5（强制刷新）：**浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。
* **地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。**

## 浏览器安全

### XSS 攻击

#### （1）概念

**XSS 攻击指的是**跨站脚本攻击**，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

**XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。**

**攻击者可以通过这种攻击方式可以进行以下操作：**

* 获取页面的数据，如DOM、cookie、localStorage；
* DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
* 破坏页面结构；
* 流量劫持（将链接指向某网站）；

#### （2）攻击类型

**XSS 可以分为存储型、反射型和 DOM 型：**

* ****存储型指的是恶意脚本会存储在目标服务器上**，当浏览器请求数据时，脚本从服务器传回并执行。**
* 反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 
* **DOM 型指的通过修改页面的 DOM 节点形成的 XSS。**

**1）存储型 XSS 的攻击步骤：**

1. **攻击者将恶意代码提交到⽬标⽹站的数据库中。 **
2. **⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 **
3. **⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 **
4. **恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。 **

**这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。**

**2）反射型 XSS的攻击步骤：**

1. **攻击者构造出特殊的 URL，其中包含恶意代码。 **
2. **⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 **
3. **⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 **
4. **恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。 **

**反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。 **

**反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。  **

**3）DOM 型 XSS的攻击步骤：**

1. **攻击者构造出特殊的 URL，其中包含恶意代码。 **
2. **⽤户打开带有恶意代码的 URL。 **
3. **⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。 **
4. **恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。 **

**DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。 **

### 如何防御 XSS 攻击？

**可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：**

* **可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。**
* **使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。**

1. **CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。**
2. **通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 **`<meta http-equiv="Content-Security-Policy">`

* **对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。**

### CSRF 攻击

#### （1）概念

**CSRF 攻击指的是**跨站请求伪造攻击**，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

**CSRF 攻击的**本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。**

#### （2）攻击类型

**常见的 CSRF 攻击有三种：**

* **GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。**
* **POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。**
* **链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。**

### 如何防御 CSRF 攻击

**CSRF 攻击可以使用以下方法来防护：**

* **进行同源检测**，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）
* **使用 CSRF Token 进行验证**，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。
* **对**Cookie 进行双重验证**，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。
* **在设置 cookie 属性的时候设置**Samesite**，限制 cookie 不能作为被第三方使用**，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。

### 什么是中间人攻击？如何防范中间人攻击

**中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。**

**攻击过程如下: **

* **客户端发送请求到服务端，请求被中间⼈截获 **
* **服务器向客户端发送公钥 **
* **中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个**伪造的**公钥，发给客户端
* **客户端收到伪造的公钥后，⽣成加密hash值发给服务器 **
* **中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器 **
* **服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端 **
* 

### 有哪些可能引起前端安全的问题

* 跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等； 
* iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；
* 跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击 
* 恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。

### 网络劫持有哪几种，如何防范？

**⽹络劫持分为两种: **

**（1）**DNS劫持**: (输⼊京东被强制跳转到淘宝这就属于dns劫持)

* **DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器**
* **302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容 **

**（2）**HTTP劫持**: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)

**DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。**

### DOS（拒绝服务）攻击和DDoS（分布式拒绝服务）攻击

**核心目标都是通过耗尽目标系统的资源（如带宽、CPU、内存），使其无法为合法用户提供服务。它们的**主要区别在于攻击来源的数量和分布方式**：

1. **DOS 攻击（Denial-of-Service，拒绝服务攻击）**

* **攻击来源：** 单台计算机或少量设备（通常由一个攻击者直接控制）。
* **攻击方式：**
  * **利用目标系统的漏洞（如缓冲区溢出）使其崩溃。**
  * **发送大量看似合法的请求（如HTTP请求）耗尽服务器资源（如SYN洪水攻击）。**
* **特点：**
  * **相对容易实施（技术门槛较低）。**
  * **相对容易防御和追踪：由于流量来自单一或少数据源，目标管理员可以通过防火墙规则（如屏蔽攻击源IP）或修复漏洞来缓解攻击。**
  * **攻击规模有限：单台机器的带宽和处理能力有限。**
* **比喻：** 一个人不停地用力敲打你家的大门，让你无法正常开门接待其他客人。

2. **DDoS 攻击（Distributed Denial-of-Service，分布式拒绝服务攻击）**

* **攻击来源：** 数量庞大的受控设备组成的“僵尸网络”（Botnet），分布在全球各地。这些设备通常是感染了恶意软件的普通用户电脑、服务器、IoT设备（如摄像头、路由器）。
* **攻击方式：**
  * **直接攻击：** 僵尸网络中的所有设备直接向目标发送大量流量（如HTTP请求、UDP数据包）。
  * **反射/放大攻击：** 攻击者伪造目标IP地址，向大量第三方服务器（如DNS服务器、NTP服务器）发送请求。这些服务器会将大得多的响应发送回目标地址，放大攻击流量（如DNS放大攻击、NTP放大攻击）。
* **特点：**
  * **规模巨大：** 成百上千甚至数百万台设备同时发动攻击，产生远超任何单点防御能力的海量流量（可达Tbps级别）。
  * **难以防御：**
    * **攻击源IP数量庞大且分散，难以通过简单IP屏蔽阻止。**
    * **流量可能看起来像正常流量，难以精确过滤。**
    * **需要部署专业的DDoS防护服务（如云清洗中心）。**
  * **难以追踪：** 攻击者隐藏在僵尸网络背后，通过多层代理或控制服务器指挥攻击，溯源困难。
  * **危害巨大：** 可导致大型网站、在线服务、网络基础设施瘫痪，造成严重经济损失和声誉损害。
* **比喻：** 成千上万个被遥控指挥的人（僵尸网络）从四面八方同时涌向你家的门、窗、烟囱，用各种方式堵塞所有入口，让你完全无法动弹，也无法接待任何正常访客。或者，攻击者遥控一大群人（僵尸网络）冒充你家地址，向邮局订购大量重物（反射服务器），导致邮局把堆积如山的包裹（放大流量）都送到你家门口把你淹没。

**关键区别总结**

| **特性**     | **DOS 攻击**                        | **DDoS 攻击**                                |
| ------------ | ----------------------------------- | -------------------------------------------- |
| **攻击源**   | **单一或少数据源**（1台或几台设备） | **海量分布式来源**（庞大僵尸网络）           |
| **攻击规模** | **相对较小**（受限于单点能力）      | **极其巨大**（Tbps级别，远超单点防御能力）   |
| **复杂性**   | **相对简单**                        | **非常复杂（需要构建/控制僵尸网络）**        |
| **防御难度** | **相对容易**（可屏蔽源头IP）        | **极其困难**（需专业防护，源头多且伪装性强） |
| **追踪难度** | **相对容易**                        | **非常困难（攻击者隐藏深）**                 |
| **危害程度** | **较小（影响范围有限）**            | **巨大（可瘫痪大型服务、基础设施）**         |
| **主导者**   | **单个攻击者**                      | **攻击者控制僵尸网络指挥中心（C&C）**        |

**为什么 DDoS 成为主流？**

* **防御技术的进步：** 基本的DOS攻击容易被现代防火墙、入侵检测系统和网络基础设施过滤掉。
* **僵尸网络的易得性：** 攻击者可以租用现成的庞大僵尸网络（即“攻击即服务”）。
* **攻击效果显著：** DDoS能产生毁灭性的流量，对大型目标也有效。
* **匿名性：** 僵尸网络提供了更好的匿名性。

**如何防御？**

* **DOS防御：** 防火墙规则、系统/应用漏洞修补、入侵检测/防御系统（IDS/IPS）、流量限速。
* **DDoS防御：**
  * **本地设备：** 部署专业的DDoS防护硬件/软件（常能力有限）。
  * **云端清洗：** 将流量路由到云服务商（如Cloudflare, Akamai, AWS Shield, 阿里云盾）的清洗中心，过滤恶意流量后再将干净流量传回目标。这是当前最主流有效的方式。
  * **带宽冗余：** 增加带宽以吸收部分攻击（成本高，对超大攻击无效）。
  * **架构设计：** 分布式架构、负载均衡、CDN等可增强韧性。

**总而言之，DDoS 是 DOS 的升级版和主流形态，利用僵尸网络的分布式特性发动规模更大、更难防御和追踪的拒绝服务攻击。** DOS 在当今环境下已较少见且相对容易防御，而防御大规模 DDoS 攻击是现代网络安全的重要挑战，通常需要借助专业的第三方防护服务。

## 浏览器本地存储

### 1. 浏览器本地存储方式及使用场景

#### **（1）Cookie**

**Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。**

**Cookie的特性：**

* **Cookie一旦创建成功，名称就无法修改**
* **Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie**
* **每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb**
* **有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的**
* **Cookie在请求一个新的页面的时候都会被发送过去**

**如果需要域名之间跨域共享Cookie，有两种方法：**

1. **使用Nginx反向代理**
2. **在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId**

**Cookie的使用场景：**

* **最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。**
* **可以用来统计页面的点击次数**

#### **（2）LocalStorage**

**LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。**

**LocalStorage的优点：**

* **在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息**
* **LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在**
* **仅储存在本地，不像Cookie那样每次HTTP请求都会被携带**

**LocalStorage的缺点：**

* **存在浏览器兼容问题，IE8以下版本的浏览器不支持**
* **如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage**
* **LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问**

**LocalStorage的常用API：**

<div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 保存数据到 localStorage</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">localStorage</span>.<span class="cm-property">setItem</span>(<span class="cm-string">'key'</span>, <span class="cm-string">'value'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 从 localStorage 获取数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">let</span> <span class="cm-def">data</span> <span class="cm-operator">=</span> <span class="cm-variable">localStorage</span>.<span class="cm-property">getItem</span>(<span class="cm-string">'key'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 从 localStorage 删除保存的数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">localStorage</span>.<span class="cm-property">removeItem</span>(<span class="cm-string">'key'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 从 localStorage 删除所有保存的数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">localStorage</span>.<span class="cm-property">clear</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 获取某个索引的Key</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">localStorage</span>.<span class="cm-property">key</span>(<span class="cm-variable">index</span>)</span></pre></div></div></div></div></div><div></div></div></div></pre>

**LocalStorage的使用场景：****

* **有些网站有换肤的功能，**这时候就可以将换肤的信息存储在本地的**LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可**
* 在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中

#### **（3）SessionStorage**

SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。

**SessionStorage与LocalStorage对比**

* SessionStorage和LocalStorage都在本地进行数据存储；
* SessionStorage也有同源策略的限制**，**但是SessionStorage有一条更加严格的限制**，**SessionStorage只有在同一浏览器的同一窗口下才能够共享；
* LocalStorage和SessionStorage都不能被爬虫爬取；

**SessionStorage的常用API：**

<div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 保存数据到 sessionStorage</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">sessionStorage</span>.<span class="cm-property">setItem</span>(<span class="cm-string">'key'</span>, <span class="cm-string">'value'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 从 sessionStorage 获取数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">let</span> <span class="cm-def">data</span> <span class="cm-operator">=</span> <span class="cm-variable">sessionStorage</span>.<span class="cm-property">getItem</span>(<span class="cm-string">'key'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 从 sessionStorage 删除保存的数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">sessionStorage</span>.<span class="cm-property">removeItem</span>(<span class="cm-string">'key'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 从 sessionStorage 删除所有保存的数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">sessionStorage</span>.<span class="cm-property">clear</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 获取某个索引的Key</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">sessionStorage</span>.<span class="cm-property">key</span>(<span class="cm-variable">index</span>)</span></pre></div></div></div></div></div><div></div></div></div></pre>

**SessionStorage的使用场景**

* 由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。

### 2. Cookie有哪些字段，作用分别是什么

**Cookie由以下字段组成：**

* **Name**：cookie的名称

* **Value**：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；

* **Size**： cookie的大小

* **Path**：可以访问此cookie的页面路径。 比如domain是abc.com，path是 `/test`，那么只有 `/test`路径下的页面可以读取此cookie。

* **Secure**： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。

* **Domain**：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。

* **HTTP**： 该字段包含 `HTTPOnly` 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过 `document.cookie`属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。

* **Expires/Max-size** ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。

* `SameSite` 是 Cookie 的一个属性，通过 **`Set-Cookie` 响应头** 由服务器发送给浏览器。语法如下：

  <div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-error">Set-Cookie: cookieName=value; SameSite=None|Lax|Strict; Secure; Domain=example.com; Path=/</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

控制浏览器是否在跨站请求中发送 Cookie，防止 CSRF 攻击。

**总结：**

服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。

**cookie跨域携带**

| **要求**        | **客户端**               | **服务器端**                                          |
| --------------- | ------------------------ | ----------------------------------------------------- |
| **凭证传递**    | `credentials: 'include'` | `Access-Control-Allow-Credentials: true`              |
| **域名限制**    | **-**                    | `Access-Control-Allow-Origin`需明确指定域名（非 `*`） |
| **Cookie 属性** | **-**                    | `SameSite=None; Secure`必须同时设置                   |
| **协议要求**    | **必须 HTTPS**           | **必须 HTTPS**                                        |

### 3. Cookie、LocalStorage、SessionStorage区别

**浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。**

* **cookie：**其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。
* **sessionStorage：**html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。
* **localStorage：**html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。

****上面三种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 **indexDB** 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。

**Web Storage 和 cookie 的区别总结如下：**

* Web Storage是为了更大容量存储设计的。Cookie 的大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中浪费了带宽；
* **cookie 需要指定作用域，不可以跨域调用；**
* Web Storage 拥有 setItem,getItem,removeItem,clear 等方法，不像 cookie 需要前端开发者自己封装 setCookie，getCookie；
* **Cookie 也是不可以或缺的：Cookie **的作用是与服务器进行交互**，作为 HTTP **规范的一部分而存在，而 Web Storage 仅仅是为了在本地“存储”数据而生。

### 4. 前端储存的⽅式有哪些？

* cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；
* localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；
* sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式； 
* Web SQL：2010年被W3C废弃的本认为地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐； 
* IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。 

### 5. IndexedDB有哪些特点？

**IndexedDB 具有以下特点：**

* **键值对储存**：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。
* **异步**：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。
* **支持事务**：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
* **同源限制：**IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。
* **储存空间大**：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。
* **支持二进制储存**：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。