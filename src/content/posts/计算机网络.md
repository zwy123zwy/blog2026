---
title: 计算机网络
published: 2026-02-14
description: '计算机网络'
image: ''
tags: []
category: ''
draft: false 
lang: 'zh-cn'
---

# 计算机网络模型

## OSI七层模型

`ISO`为了更好的使网络应用更为普及，推出了 `OSI`参考模型。

![img](./img/25037.jpg)

#### 应用层

`OSI`参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：`HTTP`，`HTTPS`，`FTP`，`POP3`、`SMTP`等。

* **在客户端与服务器中经常会有数据的请求，这个时候就是会用到** `http(hyper text transfer protocol)(超文本传输协议)`或者 `https`在后端设计数据接口时，我们常常使用到这个协议。
* `FTP`是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如 `百度网盘、迅雷`应该是基于此协议的。
* `SMTP`是 `simple mail transfer protocol（简单邮件传输协议）`。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。

#### 表示层

**表示层提供各种用于** **应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别**。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。

**在项目开发中，为了方便数据传输，可以使用** `base64`对数据进行编解码。如果按功能来划分，`base64`应该是工作在表示层。

#### 会话层

**会话层就是** **负责建立、管理和终止表示层实体之间的通信会话**。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。

#### 传输层

**传输层建立了** **主机端到端的链接**，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，`TCP``UDP`就是在这一层。端口号既是这里的“端”。

#### 网络层

**本层通过** `IP`寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的 `IP`层。这一层就是我们经常说的 `IP`协议层。`IP`协议是 `Internet`的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。

#### 数据链路层

**将比特组合成字节,再将** **字节组合成帧,**使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。

**网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。**

#### 物理层

**实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。**

**OSI七层模型通信特点：对等通信**

**对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。**

#### 数据传输

![image-20250628113806329](./img/bf34a01c9faf2dffc49a31e63858804.png)

| **OSI层**      | **PDU名称**   | **组成说明**                                                       |
| -------------------- | ------------------- | ------------------------------------------------------------------------ |
| **应用层**     | **报文/消息** | **用户数据（如HTTP请求、FTP文件）**                                |
| **表示层**     | **报文**      | **加密/压缩后的数据（如SSL/TLS加密的HTTP数据）**                   |
| **会话层**     | **报文**      | **建立/维护会话的数据（如RPC调用、NetBIOS会话）**                  |
| **传输层**     | **段**        | **TCP/UDP数据，添加端口号、校验和（如TCP段包含序列号、窗口大小）** |
| **网络层**     | **包**        | **IP数据包，包含源/目的IP地址（如IPv4包）**                        |
| **数据链路层** | **帧**        | **以太网帧，添加MAC地址、CRC校验（如Ethernet II帧）**              |
| **物理层**     | **比特流**    | **二进制信号（如电脉冲、光信号）**                                 |

**PDU的封装与解封装过程**
**数据在发送时从上到下逐层封装，接收时从下到上逐层解封装：**

**发送方（封装流程）**

* **应用层生成原始数据（如HTTP请求）。**
* **传输层（TCP/UDP）添加端口号、校验和，形成Segment。**
* **网络层（IP）添加源/目的IP地址，形成Packet。**
* **数据链路层（以太网）添加MAC地址、帧头/尾，形成Frame。**

**物理层将帧转为比特流，通过介质传输。**

* **接收方（解封装流程）物理层接收比特流，还原为帧。**
* **数据链路层校验帧，去除MAC头，提取Packet。**
* **网络层检查IP地址，去除IP头，提取Segment。**
* **传输层验证端口和校验和，去除TCP/UDP头，传递数据给应用层。**

**关键点**
**每层只处理本层的PDU**

**例如，路由器（网络层设备）只处理IP包，不关心TCP段或以太网帧的内容,交换机（数据链路层设备）只处理MAC帧，不解析IP包。**

**PDU的命名差异**

* **TCP/IP模型中：**
* **网络接口层PDU称Frame（帧）。**
* **互联网层（IP）PDU称Packet（包）。**
* **传输层（TCP/UDP）PDU仍称Segment（段）。**

**封装开销**

**每层添加的头部/尾部会增加传输开销（如以太网帧头14字节，IP头20字节，TCP头20字节）。**

##### 实例分析（HTTP over TCP/IP）

**假设用户访问一个网页，PDU变化如下：**

* **应用层：HTTP请求（GET /index.html） → Message。**
* **传输层：添加TCP头（源端口、目的端口80） → Segment。**
* **网络层：添加IP头（源IP 192.168.1.2，目的IP 93.184.216.34） → Packet。**
* **数据链路层：添加以太网头（源MAC 00:1A:2B:3C:4D:5E，目的MAC 网关MAC） → Frame。**
* **物理层：转为比特流发送。**

## Linux 接收网络包的流程

**网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。**

### 告诉操作系统网络包已到达

**那应该怎么告诉操作系统这个网络包已经到达了呢？**

**最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。**

**但是，这存在一个问题，在高性能网络场景下，网络包的数量会非常多，那么就会触发非常多的中断，要知道当 CPU 收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么频繁地触发中断，则会导致 CPU 一直没完没了的处理中断，而导致其他任务可能无法继续前进，从而影响系统的整体效率。**

**所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了** **NAPI 机制**，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是**不采用中断的方式读取数据**，而是首先采用中断唤醒数据接收的服务程序，然后 poll 的方法来轮询数据。

**因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。**

**硬件中断处理函数会做如下的事情：**

* **需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。**
* **接着，发起「软中断」，然后恢复刚才屏蔽的中断。**

**至此，硬件中断处理函数的工作就已经完成。**

**硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。**

### 软中断的处理

**内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。**

**ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 **`sk_buff` 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。

### 网络协议栈

**首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。**

**到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。**

**传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。**

**最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。**

**至此，一个网络包的接收过程就已经结束了。下图左边部分描述的就是网络包接收的流程，右边部分刚好反过来，它是网络包发送的流程。**

![网络包接收和发送流程](./img/receive-and-send-network-packets.d585a7bd.png)

## Linux 发送网络包的流程

**如上图的右半部分，发送网络包的流程正好和接收流程相反。**

### 应用层

**首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 **`sk_buff` 内存，** **将用户待发送的数据拷贝到 `sk_buff` 内存，并将其加入到发送缓冲区**。

### 传输层

**接下来，网络协议栈从 Socket 发送缓冲区中取出 **`sk_buff`，并按照 TCP/IP 协议栈从上到下逐层处理。

**如果使用的是 TCP 传输协议发送数据，那么** **先拷贝一个新的 `sk_buff` 副本**，这是因为 `sk_buff` 后续在调用网络层，最后到达网卡发送完成的时候，这个 `sk_buff` 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 `sk_buff` 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 `sk_buff` 的一个拷贝，等收到 ACK 再真正删除。

**接着，对 **`sk_buff` 填充 TCP 头。这里提一下，`sk_buff` 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment（段），在 IP 层我们叫 packet（包），在数据链路层称为 frame（帧）。

**你可能会好奇，为什么全部数据包只用一个结构体来描述呢？协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低 CPU 效率。**

**于是，为了在层级之间传递数据时，不发生拷贝，只用 **`sk_buff` 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 `sk_buff` 中 data 的指针，比如：

* **当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb -> data 的值，来逐步剥离协议首部。**
* **当要发送报文时，创建 **`sk_buff` 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb -> data 的值来增加协议首部。

**至此，传输层的工作也就都完成了。**

### 网络层

**然后交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。**

### 网络接口层

**网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 **`sk_buff` 填充帧头和帧尾，接着将 `sk_buff` 放到网卡的发送队列中。

### 通知网卡有包要发送

**这一些工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 **`sk_buff`，将这个 `sk_buff` 挂到 RingBuffer 中，接着将 `sk_buff` 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。

### 完成网络包的发送

**当数据发送完成以后，其实工作并没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放 **`sk_buff` 内存和清理 RingBuffer 内存。

**最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 **`sk_buff` 。

**发送网络数据的时候，涉及几次内存拷贝操作？**

* **第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 **`sk_buff` 内存，将用户待发送的数据拷贝到 `sk_buff` 内存，并将其加入到发送缓冲区。
* **第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 **`sk_buff` 都会被克隆一个新的副本出来。副本 `sk_buff` 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 `sk_buff` 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 `sk_buff`。
* **第三次，当 IP 层发现 **`sk_buff` 大于 MTU 时才需要进行。会再申请额外的 `sk_buff`，并将原来的 `sk_buff` 拷贝为多个小的 `sk_buff`。

### **总结**

**电脑与电脑之间通常都是通过话网卡、交换机、路由器等网络设备连接到一起，那由于网络设备的异构性，国际标准化组织定义了一个七层的 OSI 网络模型，但是这个模型由于比较复杂，实际应用中并没有采用，而是采用了更为简化的 TCP/IP 模型，Linux 网络协议栈就是按照了该模型来实现的。**

**TCP/IP 模型主要分为应用层、传输层、网络层、网络接口层四层，每一层负责的职责都不同，这也是 Linux 网络协议栈主要构成部分。**

**当应用程序通过 Socket 接口发送数据包，数据包会被网络协议栈从上到下进行逐层处理后，才会被送到网卡队列中，随后由网卡将网络包发送出去。**

**而在接收网络包时，同样也要先经过网络协议栈从下到上的逐层处理，最后才会被送到应用程序。**

**在网上看到一张不错的动图，附上：**

![OSI 七层协议数据传输的封包与解包过程](./img/receive-and-send-network-packets-in-osi.70a653a6.gif)

**各层协议与设备**
![](./img/16ce7eb72c0dc44c.webp)

![](./img/16ce7ee86d166933.webp)

# IP

## IP协议的基本功能

**IP的主要目的是通过一个互联的网络传输数据报，涉及两个最基本的功能。**

* **寻址（Addressing）**：IP协议根据数据报首部中包括的目的地址将数据报传送到目的节点，这就要涉及传送路径的选择，即路由功能。IP协议使用IP地址来实现路由。
* **分片（Fragmentation）**：IP协议还提供对数据大小的分片和重组，以适应不同网络对数据包大小的限制。如果网络只能传送小数据包，IP协议将对数据报进行分段并重新组成小块再进行传送

## IP协议的特性

**IP 是一个** **无连接的、不可靠的、点对点** 的协议，只能尽力（Best Effort）传送数据，不能保证数据的到达。

**在IP网络中，“点对点”（Point-to-Point，简称P2P）指** **两个网络节点之间建立直接、独占的通信链路**

**具体地讲，主要有以下特性。**

* **IP协议提供无连接数据报服务，各个数据报独立传输，可能沿着不同的路径到达目的地，也可能不会按序到达目的地。**
* **IP 协议不含错误检测或错误恢复的编码，属于不可靠的协议。所谓不可靠，是从数据传输的可靠性不能保证的角度而言的，查询的延误及其他网络通信故障都有可能导致所传数据的丢失。对这种情况，IP 协议本身不处理。它的不可靠并不能说明整个 TCP/IP 协议不可靠。如果要求数据传输具有可靠性，则要在IP的上面使用TCP协议加以保证。位于上一层的TCP协议则提供了错误检测和恢复机制。**
* **作为一种点对点协议，虽然 IP 数据报携带源 IP 地址和目的 IP 地址，但进行数据传输时的对等实体一定是相邻设备（同一网络）中的对等实体。**
* **IP协议的效率非常高，实现起来也较简单。这是因为IP协议采用了尽力传输的思想，随着底层网络质量的日益提高，IP协议的尽力传输的优势体现得更加明显。**

## IP协议的工作方式

**在一个路由式网络中，源地址主机向目标地址主机发送数据时，IP协议是如何将数据成功发送到目标主机上的呢？由于网络分同网段和不同网段两种情况，工作方式如下：**

### 同网段

**如果源地址主机和目标地址主机在同一网段，目标IP地址被ARP协议解析为MAC地址，然后根据MAC地址，源主机直接把数据包发给目标主机。**

### 不同网段

**如果源地址主机和目标地址主机在不同网段，数据包发送过程如下：**

**（1）网关（一般为路由器）的IP地址被ARP协议解析为MAC地址。根据该MAC地址，源主机将数据包发送到网关。**

**（2）网关根据数据包中的网段ID寻找目标网络。如果找到，将数据包发送到目标网段；如果没找到，重复步骤（1）将数据包发送到上一级网关。**

**（3）数据包经过网关被发送到正确的网段中。目标IP地址被ARP协议解析为MAC地址。根据该MAC地址，数据包被发送给目标地址的主机。**

## **ip地址分类**

* **A类地址：范围从0.0.0.0到127.255.255.255，默认子网掩码为255.0.0.0，适用于大型网络。**
* **B类地址：范围从128.0.0.0到191.255.255.255，默认子网掩码为255.255.0.0，适用于中型网络。**
* **C类地址：范围从192.0.0.0到223.255.255.255，默认子网掩码为255.255.255.0，适用于小型网络。**
* **D类地址：范围从224.0.0.0到239.255.255.255，用于多播地址。**
* **E类地址：范围从240.0.0.0到255.255.255.255，保留用于实验和研究。**

![](./img/21928.jpg)

# TCP、UDP

## TCP 和 UDP的概念及特点

**TCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族：**

**（1）UDP**

**UDP的全称是** **用户数据报协议**，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。

**它的特点如下：**

**1）面向无连接**

**首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。**

**具体来说就是：**

* **在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了**
* **在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作**

**2）有单播，多播，广播的功能**

**UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。**

**3）面向报文**

**发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文**

**4）不可靠性**

**首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。**

**并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。**

**再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。**

**5）头部开销小，传输数据报文时是很高效的。**

![img](./img/2019-03-21-03.png)

**UDP 头部包含了以下几个数据：**

* **两个十六位的端口号，分别为源端口（可选字段）和目标端口**
* **整个数据报文的长度**
* **整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误**

**因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。**

**（2）TCP**

**TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。**

**它有以下几个特点：**

**1）面向连接**

**面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。**

**2）仅支持单播传输**

**每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。**

**3）面向字节流**

**TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。**

**4）可靠传输**

**对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。**

**5）提供拥塞控制**

**当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。**

**6）提供全双工通信**

**TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）**

## TCP和UDP的区别

|                        | **UDP**                                        | **TCP**                                                  |
| ---------------------- | ---------------------------------------------------- | -------------------------------------------------------------- |
| **是否连接**     | **无连接**                                     | **面向连接**                                             |
| **是否可靠**     | **不可靠传输，不使用流量控制和拥塞控制**       | **可靠传输（数据顺序和正确性），使用流量控制和拥塞控制** |
| **连接对象个数** | **支持一对一，一对多，多对一和多对多交互通信** | **只能是一对一通信**                                     |
| **传输方式**     | **面向报文**                                   | **面向字节流**                                           |
| **首部开销**     | **首部开销小，仅8字节**                        | **首部最小20字节，最大60字节**                           |
| **适用场景**     | **适用于实时应用，例如视频会议、直播**         | **适用于要求可靠传输的应用，例如文件传输**               |

## TCP和UDP的使用场景

* **TCP应用场景：** 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
* **UDP应用场景：** 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。

## UDP协议为什么不可靠？

**UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：**

* **不保证消息交付：不确认，不重传，无超时**
* **不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞**
* **不跟踪连接状态：不必建立连接或重启状态机**
* **不进行拥塞控制：不内置客户端或网络反馈机制**

## TCP

### 三次握手

![img](./img/850de5c566ae60989f45cff4b1aad94c.png)

**三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。**

**刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。**

* **第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。**

**首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。**

* **第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。**

**在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y**

* **第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。**

**确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。**

**那为什么要三次握手呢？两次不行吗？**

* **为了确认双方的接收能力和发送能力都正常**
* **如果是用两次握手，则会出现下面这种情况：**

**如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。**

#### 第一次握手丢失了，会发生什么？

**当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 **`SYN_SENT` 状态。

**在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「**超时重传**」机制，重传 SYN 报文，而且**重传的 SYN 报文的序列号都是一样的**。

**对于超时时间，不同版本的操作系统可能不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。**

**当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？**

**在 Linux 里，客户端的 SYN 报文最大重传次数由 **`tcp_syn_retries` 内核参数控制，这个参数是可以自定义的，默认值一般是 5。

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n369" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># cat /proc/sys/net/ipv4/tcp_syn_retries</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-number">5</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

**通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，**每次超时的时间是上一次的 2 倍**。

**当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。**

**所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。**

**举个例子，假设 **`tcp_syn_retries` 参数值为 3，那么当客户端的 SYN 报文一直在网络中丢失时，会发生下图的过程：

![第一次握手丢失](./img/lost-in-first-handshake.b62af538.png)

**（第一次握手丢失）**

**具体过程：**

* **当客户端超时重传 3 次 SYN 报文后，由于 **`tcp_syn_retries` 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。

#### 第二次握手丢失了，会发生什么？

**当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 **`SYN_RCVD` 状态。

**第二次握手的 SYN-ACK 报文其实有两个目的：**

* **第二次握手里的 ACK， 是对第一次握手的确认报文；**
* **第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；**

**所以，如果第二次握手丢了，就会发生比较有意思的事情，具体会怎么样呢？**

**因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是**客户端就会触发超时重传机制，重传 SYN 报文**。

**然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。**

**那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 SYN-ACK 报文。**

**因此，当第二次握手丢失了，** **客户端和服务端都会重传**：

* **客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 **`tcp_syn_retries` 内核参数决定；
* **服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 **`tcp_synack_retries` 内核参数决定。

**在 Linux 下，SYN-ACK 报文的最大重传次数由 **`tcp_synack_retries` 内核参数决定，默认值是 5。

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n399" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># cat /proc/sys/net/ipv4/tcp_synack_retries</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-number">5</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

**举个例子，假设 **`tcp_syn_retries` 参数值为 1，`tcp_synack_retries` 参数值为 2，那么当第二次握手一直丢失时，发生的过程如下图：

![第二次握手丢失](./img/lost-in-second-handshake.1e63a9ff.png)

**具体过程：**

* **当客户端超时重传 1 次 SYN 报文后，由于 **`tcp_syn_retries` 为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。
* **当服务端超时重传 2 次 SYN-ACK 报文后，由于 **`tcp_synack_retries` 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。

#### 第三次握手丢失了，会发生什么？

**客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 **`ESTABLISH` 状态。

**因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。**

**注意，** **ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**。

**举个例子，假设 **`tcp_synack_retries` 参数值为 2，那么当第三次握手一直丢失时，发生的过程如下图：

![第三次握手丢失](./img/lost-in-third-handshake.7f728e63.png)

**具体过程：**

* **当服务端超时重传 2 次 SYN-ACK 报文后，由于 **`tcp_synack_retries` 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。

#### 关于 SYN 攻击

##### 什么是 SYN 攻击

**我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 **`SYN` 报文**，服务端每接收到一个 `SYN` 报文，就进入 `SYN_RCVD` 状态，但服务端发送出去的 `SYN-ACK` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会 **占满服务端的半连接队列**，使得服务器不能为正常用户服务。

![SYN 攻击](./img/syn-attack.23a59005.png)

**下面先来看一下什么是 TCP 半连接和全连接队列。**

##### 半连接和全连接队列

**在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：**

* **半连接队列，也称 SYN 队列。**
* **全连接队列，也称 Accpet 队列。**

**先来看下 Linux 内核的 **`SYN` 队列（半连接队列）与 `Accpet` 队列（全连接队列）是如何工作的？

![SYN 攻击](./img/syn-queue-and-accpet-queue-1.61cea3b1.png)

**正常流程：**

* **当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「SYN 队列」。**
* **接着发送 SYN-ACK 给客户端，等待客户端回应 ACK 报文。**
* **服务端接收到 ACK 报文后，从「SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「Accept 队列」。**
* **应用通过调用 **`accpet()` socket 接口，从「Accept 队列」取出连接对象。

**不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。**

**SYN 攻击方式最直接的表现就是把 TCP 半连接队列打满，这样**当 TCP 半连接队列满了，后续再收到 SYN 报文就会丢弃**，导致客户端无法和服务端建立连接。

#### 避免 SYN 攻击方式

**避免 SYN 攻击方式，可以有以下四种方法：**

* **调大 **`netdev_max_backlog`
* **增大 TCP 半连接队列**
* **开启 **`tcp_syncookies`
* **减少 SYN-ACK 重传次数**

##### 1）方式一：调大 `netdev_max_backlog`

**当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数，默认值是 1000，我们要适当调大该参数的值，比如设置为 10000：**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n460" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">net.core.netdev_max_backlog <span class="cm-operator">=</span> <span class="cm-number">10000</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

##### 2）方式二：增大 TCP 半连接队列

**增大 TCP 半连接队列，要同时增大下面这三个参数：**

* **增大 **`net.ipv4.tcp_max_syn_backlog`
* **增大 **`listen()` 函数中的 `backlog`
* **增大 **`net.core.somaxconn`

**具体为什么是这三个参数决定 TCP 半连接队列的大小，这里暂不深入研究。**

##### 3）方式三：开启 `net.ipv4.tcp_syncookies`

**开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。**

![SYN 队列占满，启动 cookie](./img/syn-queue-and-accpet-queue-2.65bc64b2.png)

**具体过程：**

* **当「SYN 队列」满之后，后续服务器收到 SYN 包，不会丢弃，而是根据算法，计算出一个 cookie 值。**
* **将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端。**
* **服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「Accept 队列」。**
* **最后应用程序通过调用 **`accpet()` 接口，从「Accept 队列」取出的连接。

**可以看到，当开启了 **`tcp_syncookies` 了，即使受到 SYN 攻击而导致 SYN 队列满时，也能保证正常的连接成功建立。

`net.ipv4.tcp_syncookies` 参数主要有以下三个值：

* `0` 值，表示关闭该功能。
* `1` 值，表示仅当 SYN 半连接队列放不下时，再启用它。
* `2` 值，表示无条件开启功能。

**那么在应对 SYN 攻击时，只需要设置为 **`1` 即可：

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n495" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-def">$ echo</span> <span class="cm-number">1</span> > /proc/sys/net/ipv4/tcp_syncookies</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

##### 4）减少 SYN-ACK 重传次数

**当服务端受到 SYN 攻击时，就会有大量处于 **`SYN_REVC` 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN-ACK ，当重传超过次数达到上限后，就会断开连接。

**那么针对 SYN 攻击的场景，我们可以减少 SYN-ACK 的重传次数，以加快处于 **`SYN_REVC` 状态的 TCP 连接断开。

**SYN-ACK 报文的最大重传次数由 **`tcp_synack_retries` 内核参数决定（默认值是 5 次），比如将 `tcp_synack_retries` 减少到 2 次：

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n500" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-def">$ echo</span> <span class="cm-number">2</span> > /proc/sys/net/ipv4/tcp_synack_retries</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

### 四次挥手

![img](./img/0dc25c2e6ae3de02cc4039553165d8cf.png)

**刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：**

* **第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。**

**即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。**

* **第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。**

**即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。**

* **第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。**

**即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。**

* **第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。**

**即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。**

**那为什么需要四次挥手呢？**

**因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。**

**简单来说就是以下四步：**

* **第一次挥手**：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。
* **第二次挥手**：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。
* **第三次挥手**：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。
* **第四次挥手**：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

**TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。**

**最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭**

#### 第一次挥手丢失了，会发生什么？

**当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 **`FIN_WAIT_1` 状态。

**正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 **`FIN_WAIT2` 状态。

**如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发**超时重传**机制，重传 FIN 报文，重发次数由 `tcp_orphan_retries` 参数控制。

**当客户端重传 FIN 报文的次数超过 **`tcp_orphan_retries` 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 `close` 状态。

**举个例子，假设 **`tcp_orphan_retries` 参数值为 3，当第一次挥手一直丢失时，发生的过程如下图：

![第一次挥手丢失](./img/lost-in-first-wave.c639c167.png)

**具体过程：**

* **当客户端超时重传 3 次 FIN 报文后，由于 **`tcp_orphan_retries` 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。

#### 第二次挥手丢失了，会发生什么？

**当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 **`CLOSE_WAIT` 状态。

**在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。**

**举个例子，假设 **`tcp_orphan_retries` 参数值为 2，当第二次挥手一直丢失时，发生的过程如下图：

![第二次挥手丢失](./img/lost-in-second-wave.27229796.png)

**具体过程：**

* **当客户端超时重传 2 次 FIN 报文后，由于 **`tcp_orphan_retries` 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。

**这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 **`FIN_WAIT2` 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。

**对于 close 函数关闭的连接，由于无法再发送和接收数据，所以 **`FIN_WAIT2` 状态不可以持续太久，而 `tcp_fin_timeout` 控制了这个状态下连接的持续时长，默认值是 60 秒。

**这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭，如下图：**

![调用 close 关闭的连接](./img/fin_wait_2-by-close.59fd1ca9.png)

**但是注意，如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。**

**此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 **`FIN_WAIT2` 状态（`tcp_fin_timeout` 无法控制 shutdown 关闭的连接）。如下图：

![调用 shutdown 关闭的连接](./img/fin_wait_2-by-shutdown.f485c6fb.png)

#### 第三次挥手丢失了，会发生什么？

**当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 **`CLOSE_WAIT` 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。

**此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。**

**服务端处于 **`CLOSE_WAIT` 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 `LAST_ACK` 状态，等待客户端返回 ACK 来确认连接关闭。

**如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 **`tcp_orphan_retries` 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。

**举个例子，假设 **`tcp_orphan_retries = 3`，当第三次挥手一直丢失时，发生的过程如下图：

![第三次挥手丢失](./img/lost-in-third-wave.b8f03061.png)

**具体过程：**

* **当服务端重传第三次挥手报文的次数达到了 3 次后，由于 **`tcp_orphan_retries` 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。
* **客户端因为是通过 close 函数关闭连接的，处于 **`FIN_WAIT_2` 状态是有时长限制的，如果 `tcp_fin_timeout` 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。

#### 第四次挥手丢失了，会发生什么？

**当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 **`TIME_WAIT` 状态。

**在 Linux 系统，**`TIME_WAIT` 状态会持续 2MSL 后才会进入关闭状态。

**然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 **`LAST_ACK` 状态。

**如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 **`tcp_orphan_retries` 参数控制。

**举个例子，假设 **`tcp_orphan_retries` 为 2，当第四次挥手一直丢失时，发生的过程如下：

![第四次挥手丢失](./img/lost-in-fourth-wave.80200bab.png)

**具体过程：**

* **当服务端重传第三次挥手报文达到 2 时，由于 **`tcp_orphan_retries` 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。
* **客户端在收到第三次挥手后，就会进入 **`TIME_WAIT` 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。

#### 关于 `TIME_WAIT`

##### 为什么 `TIME_WAIT` 等待的时间是 2MSL？

`MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 `TTL` 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

**MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡。

**TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了**。

`TIME_WAIT` 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**。

**比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。**

**可以看到** **2MSL时长** 这其实是相当于**至少允许报文丢失一次**。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，`TIME_WAIT` 状态的连接可以应对。

**为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。**

`2MSL` 的时间是**从客户端接收到 FIN 后发送 ACK 开始计时的**。如果在 `TIME_WAIT` 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 **2MSL 时间将重新计时**。

**在 Linux 系统里** **`2MSL` 默认是 `60` 秒，那么一个 `MSL` 也就是 `30` 秒。** Linux 系统停留在 `TIME_WAIT` 的时间为固定的 60 秒。

**其定义在 Linux 内核代码里的名称为 **`TCP_TIMEWAIT_LEN`：

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="c" cid="n612" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-meta">#define TCP_TIMEWAIT_LEN (60*HZ) </span><span class="cm-comment">/* how long to wait to destroy TIME-WAIT </span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">                                    <span class="cm-comment">state, about 60 seconds  */</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

**如果要修改 **`TIME_WAIT` 的时间长度，只能修改 Linux 内核代码里 `TCP_TIMEWAIT_LEN` 的值，并重新编译 Linux 内核。

##### 为什么需要 `TIME_WAIT` 状态？

**主动发起关闭连接的一方，才会有 **`TIME_WAIT` 状态。

**需要 **`TIME_WAIT` 状态，主要是两个原因：

* **防止历史连接中的数据，被后面相同四元组的连接错误的接收。**
* **保证「被动关闭连接」的一方，能被正确的关闭。**

##### `TIME_WAIT` 过多有什么危害？

**过多的 **`TIME_WAIT` 状态主要的危害有两种：

* **第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。**
* **第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 **`32768～61000`，也可以通过 `net.ipv4.ip_local_port_range` 参数指定范围。

**客户端和服务端 **`TIME_WAIT` 过多，造成的影响是不同的。

**如果客户端（发起连接方）的 `TIME_WAIT` 状态过多**，占满了所有端口资源，那么就无法对「目的IP + 目的PORT」都一样的服务器发起连接了，但是被使用的端口，还是可以继续对另外一个服务器发起连接的。具体可以看这篇文章：[客户端的端口可以重复使用吗？](https://wenyuan.github.io/basic-skills/network/tcp-wave-exception/#%E8%BF%98%E6%B2%A1%E5%86%99)

**因此，客户端（发起连接方）都是和「目的IP + 目的PORT 」都一样的服务器建立连接的话，当客户端的 **`TIME_WAIT` 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的IP + 目的PORT」都一样的服务器建立连接了。

**不过，即使是在这种场景下，只要连接的是不同的服务器，端口是可以重复使用的，所以客户端还是可以向其他服务器发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。**

**如果服务端（发起连接方）的 `TIME_WAIT` 状态过多**，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。

#### 如何优化 `TIME_WAIT`？

**这里给出优化 **`TIME_WAIT` 的几个方式，都是有利有弊：

* **打开 **`net.ipv4.tcp_tw_reuse` 和 `net.ipv4.tcp_timestamps` 选项。
* `net.ipv4.tcp_max_tw_buckets`
* **程序中使用 **`SO_LINGER`，应用强制使用 `RST` 关闭。

**1）方式一：`net.ipv4.tcp_tw_reuse` 和 `tcp_timestamps`**

**如下的 Linux 内核参数开启后，则可以 **复用处于 `TIME_WAIT` 的 socket 为新的连接所用**。

**有一点需要注意的是，** **`tcp_tw_reuse` 功能只能用客户端（连接发起方），因为开启了该功能，在调用 `connect()` 函数时，内核会随机找一个 `time_wait` 状态超过 `1` 秒的连接给新的连接复用**。

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n646" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">net.ipv4.tcp_tw_reuse <span class="cm-operator">=</span> <span class="cm-number">1</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

**使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n648" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">net.ipv4<span class="cm-def">.tcp_timestamps</span><span class="cm-operator">=</span><span class="cm-number">1</span>（默认即为 <span class="cm-number">1</span>）</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

**这个时间戳的字段是在 TCP 头部的「选项」里，它由一共 8 个字节表示时间戳，其中第一个 4 字节字段用来保存发送该数据包的时间，第二个 4 字节字段用来保存最近一次接收对方发送到达数据的时间。**

**由于引入了时间戳，我们在前面提到的 **`2MSL` 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。

**2）方式二：`net.ipv4.tcp_max_tw_buckets`**

**这个值默认为 18000，** **当系统中处于 `TIME_WAIT` 的连接一旦超过这个值时，系统就会将后面的 `TIME_WAIT` 连接状态重置**，这个方法比较暴力。

**3）方式三：程序中使用 `SO_LINGER`**

**我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n655" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">struct linger so_linger;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">so_linger.l_onoff <span class="cm-operator">=</span> <span class="cm-number">1</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">so_linger.l_linger <span class="cm-operator">=</span> <span class="cm-number">0</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">setsockopt(s, SOL_SOCKET, SO_LINGER, &so_linger,sizeof(so_linger));</span></pre></div></div></div></div></div><div></div></div></div></pre>

**如果 **`l_onoff` 为非 0， 且 `l_linger` 值为 0，那么调用 `close` 后，会立该发送一个 `RST` 标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了 `TIME_WAIT` 状态，直接关闭。

**但这为跨越 **`TIME_WAIT` 状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。

**前面介绍的方法都是试图越过 **`TIME_WAIT` 状态的，这样其实不太好。虽然 `TIME_WAIT` 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。

**所以更好的方法应该是：**

**如果服务端要避免过多的 `TIME_WAIT` 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 `TIME_WAIT`**。

### TCP 重传机制

#### 超时重传

**重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，如果还没有收到对方的ACK确认应答报文，就会重发该数据，也就是我们常说的超时重传。**

**那么这个指定的时间，应该是多久比较合适呢？**
** 这里先介绍两个概念：**`RTT`和 `RTO`

* `RTT`(Round-Trip Time) 往返时延，指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间
* `RTO`(Retransmission Timeout)，就是超时重传时间。

**通常** `RTO`应该略大于 `RTT`：

* **如果** `RTO`太短，有可能数据没有丢失就重发，增加网络拥塞。
* **如果** `RTO`太长，重发就慢，性能差。

**由于网络的不稳定，**`RTT`是经常变化的，导致 `RTO`也会是一个动态变化的值。

**如果超时重发的数据，再次超时的话，下一次重传的时间间隔则会加倍。**
** 超时重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？**

**TCP用** **快速重传** 机制来解决超时重发的时间等待。

#### 快速重传

**发送方发包的时候，并不总是等待ACK的响应再发送下一个包，而是会在窗口大小内，连续发多个包：**

**如果其中一个包丢失了，而后续的包到达时，接收方会发丢失的包的ACK给发送方。当发送方连接收到三个相同的ACK时，就知道这个包丢失了，于是不用等重传定时，直接就可以重新发送了**

#### SACK

**快速重传机制解决了超时时间的问题，但是它面临着另外一个问题：那就是重传的时候，是重传一个包，还是重传所有的包？像上面的例子，客户端发出19个包，当触发快速重传的时候，客户端只知道第2个包丢失了，那其他包是否丢失，客户端并不清楚，这时候有两种选择：**

* **重发2~19所有的包，显然会造成数据的浪费，因为后面17个包都是已经收到的。**
* **只重发第2个包。但如果第3个包也丢失的话，那么又得等到三次ACK才能重发第3个包，效率较低。**

**这时候，** **`SACK(Selective Acknowledgment)`，选择性确认，就可以起作用了。**
**这种方式需要在TCP头部** **选项** 字段里加一个 `SACK`的选项，它可以将已收到的数据的信息发送给发送方 ，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据了 。

**在这个例子中，**`SACK`表示 `15870601~15873581`之间的数据是已经收到的，所以客户端只需要重发 `15869201~15870600`之间的数据就行了。

**由于TCP头部大小的限制，在选项中最多能支持四组SACK的数据**

### TCP的拥塞控制机制

**TCP的拥塞控制机制主要是以下四种机制：**

* **慢启动（慢开始）**
* **拥塞避免**
* **快速重传**
* **快速恢复**

**（1）慢启动（慢开始）**

* **在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）**
* **思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。**
* **为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)**
* * **当cnwd < ssthresh，使用慢开始算法**
  * **当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法**
  * **当cnwd > ssthresh，使用拥塞避免算法**

**（2）拥塞避免**

* **拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。**
* **思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一**
* **无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:**
  ![img](./img/20200802172257514.png)
  **其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。**

**（3）快速重传**

* **快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。**
* **由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量**

**（4）快速恢复**

* **当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。**
* **考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。**
  ![img](./img/2020080217284188.png)

### TCP的流量控制机制

**一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的 **滑动窗口** 进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。

* **当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。**
* **当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）**
* **如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。**
* **如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。**

# HTTP

**HTTP 是** **超文本传输协议**，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 **80 端口**。它使用 **TCP** 作为传输层协议，保证了数据传输的可靠性。

**HTTP协议具有以下** **优点**：

* **支持** **客户端/服务器** 模式
* **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
* **无连接**：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
* **无状态**：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。
* **灵活**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

**HTTP协议具有以下** **缺点**：

* **无状态：**HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。
* **明文传输：**协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
* **不安全**

**（1）通信使用明文（不加密），内容可能会被窃听；**

**（2）不验证通信方的身份，因此有可能遭遇伪装；**

**（3）无法证明报文的完整性，所以有可能已遭篡改；**

## 请求报文

**请求报⽂有4部分组成: **

* **请求⾏ ：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 **
* **请求头部 **
* **请求头部：**
  **由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔  **
  * **User-Agent：产⽣请求的浏览器类型。 **
  * **Accept：客户端可识别的内容类型列表。 **
  * **Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机**
* **空⾏**
* **请求体 ：post put等请求携带的数据**

**请求方法：**

| **请求方法**   | **get**                                  | **post**                                     | **put**            |
| -------------------- | ---------------------------------------------- | -------------------------------------------------- | ------------------------ |
| **幂等**       | **Get 请求用于对服务器资源不会产生影响** | **更新服务器资源**                           | **创建服务器资源** |
| **缓存**       | **请求缓存**                             | **默认不缓存**                               | **默认不缓存**     |
| **数据位置**   | **URL**                                  | **请求体body**                               | **请求体body**     |
| **浏览器刷新** | **回车/刷新无害**                        | **重复提交会触发警告（需确认是否重新发送）** |                          |

**options方法**

**OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。**

**OPTIONS方法是用于请求获得由** `Request-URI`标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以**在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能**。该请求方法的响应不能缓存。

**OPTIONS请求方法的** **主要用途** 有两个：

* **获取服务器支持的所有HTTP请求方法；**
* **用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限**

**简单请求 (Simple Request)**

**一个请求必须** **同时满足以下所有条件**，才是简单请求：

1. **HTTP 方法限制为以下三种之一：**
   * `GET`
   * `HEAD`
   * `POST`
2. **HTTP 头部限制 (由浏览器自动设置的头除外)：** 只能包含以下**安全列表**中的请求头字段：
   * `Accept`
   * `Accept-Language`
   * `Content-Language`
   * `Content-Type` (但值有额外限制，见下一点)
   * `DPR`
   * `Downlink`
   * `Save-Data`
   * `Viewport-Width`
   * `Width`
   * **... (这个列表相对固定，主要是浏览器自动设置或非常基础的头部)**
3. **`Content-Type` 头的值限制为以下三种之一：**
   * `application/x-www-form-urlencoded`
   * `multipart/form-data`
   * `text/plain`

**简单请求的特点：**

* **浏览器会** **直接发送** 实际请求（GET/POST等）。
* **在请求中自动添加 **`Origin` 头，表明来源。
* **服务器需要在响应中包含至少 **`Access-Control-Allow-Origin` 头（值可以是 `*` 或具体的请求来源域）来允许跨域。如果涉及凭据（如 Cookies），还需要 `Access-Control-Allow-Credentials: true`。
* **常见例子：**
  * **使用原生 HTML **`<form>` 提交的 POST 请求（`enctype` 为上述三种之一）。
  * **使用原生 **`XMLHttpRequest` 或 `fetch` 发起的 GET 请求（不带自定义头，`Content-Type` 为上述三种之一）。
  * **使用 **`fetch` 发起的 POST 请求，请求体是 `FormData` 或 URL 编码字符串，且没有设置自定义头。

**非简单请求 (Preflighted Request / 预检请求)**

**如果一个请求** **不满足** 上述简单请求的**任何一个条件**，它就是**非简单请求**（预检请求）。

**触发非简单请求的常见情况：**

1. **使用了 `GET`, `HEAD`, `POST` 之外的 HTTP 方法：**
   * `PUT`
   * `DELETE`
   * `PATCH`
   * `CONNECT`
   * `OPTIONS` (虽然 OPTIONS 本身用于预检，但其他方法触发预检时用 OPTIONS)
   * `TRACE`
   * **或者任何自定义方法（如 `PURGE`）**
2. **设置了不在“安全列表”中的请求头：**
   * **任何** **自定义请求头**（如 `X-Auth-Token`, `X-Requested-With`）。
   * **一些不在安全列表中的标准头（如 **`Authorization`, `Content-Type` 的值超出简单请求范围）。
3. **`Content-Type` 的值不是简单请求允许的三种：**
   * **最常见的就是 **`application/json`。
   * `application/xml` 或 `text/xml` 等。
   * **任何其他非 **`text/plain`, `application/x-www-form-urlencoded`, `multipart/form-data` 的值。

**非简单请求的特点：**

* **浏览器会先自动发送一个 `OPTIONS` 方法的“预检请求”** 到目标服务器。
* **预检请求携带关键头信息询问服务器：**
  * `Origin`: 请求来源。
  * `Access-Control-Request-Method`: 后续实际请求想要使用的 HTTP 方法（如 PUT, DELETE）。
  * `Access-Control-Request-Headers`: 后续实际请求想要携带的自定义请求头列表（如 `Content-Type`, `Authorization`）。
* **服务器必须响应预检请求 (`OPTIONS`)：**
  * **返回状态码通常是 **`204 No Content` 或 `200 OK`。
  * **必须包含关键的 CORS 响应头：**
    * `Access-Control-Allow-Origin`: 允许的来源（`*` 或具体域）。
    * `Access-Control-Allow-Methods`: 允许的实际请求方法（如 `PUT, DELETE`）。
    * `Access-Control-Allow-Headers`: 允许的实际请求头（如 `Content-Type, Authorization`）。
    * **(可选) **`Access-Control-Allow-Credentials: true`（如需凭据）。
    * **(可选) **`Access-Control-Max-Age`: 预检结果缓存时间（秒）。
* **浏览器决策：**
  * **如果预检响应头**符合**后续实际请求的要求（方法、头、来源都被允许），浏览器才会**接着发送真正的实际请求**（PUT, DELETE, 带 JSON 的 POST 等）。
  * **如果预检响应头**拒绝**了实际请求（比如没包含某个方法或头），浏览器会**阻止**后续实际请求的发送，并在控制台报 CORS 错误。
* **常见例子：**
  * **发送 **`application/json` 数据的 POST/PUT 请求。
  * **发送 DELETE 请求。**
  * **在请求头中添加 **`Authorization: Bearer <token>` 进行认证。
  * **发送任何自定义 HTTP 方法的请求。**
  * **使用自定义头如 **`X-Custom-Header`。

## 响应报文

**请求报⽂有4部分组成: **

* **响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。 **
* **响应头：响应部⾸组成 **
* **空行**
* **响应体：服务器响应的数据**

## HTTP 版本演进对比

| **特性**         | **HTTP/0.9 (1991)**          | **HTTP/1.0 (1996)**                                      | **HTTP/1.1 (1997/1999)**                                                | **HTTP/2 (2015)**                                   | **HTTP/3 (2022)**                         |
| ---------------------- | ---------------------------------- | -------------------------------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------- | ----------------------------------------------- |
| **协议基础**     | **单行文本协议**             | **文本协议 + 头部**                                      | **文本协议（增强版）**                                                  | **二进制分帧协议**                                  | **基于 QUIC 的 UDP 协议**                 |
| **连接方式**     | **⚡ 单请求后立即关闭**      | **⚡ 默认短连接（可手动设** `Connection: keep-alive`） | **✅**默认长连接**（持久化）                                          | **✅ 多路复用单连接**                               | **✅ 多路复用 +**连接迁移**             |
| **并行请求**     | **❌ 不支持**                | **❌ 不支持（串行）**                                    | **🟡 有限并行（6-8个/域名，需域名分片）**                               | **✅**真并行**（单连接多流）                      | **✅**零队头阻塞**（流独立）            |
| **头部传输**     | **❌ 无头部**                | **✅ 文本头部（未压缩）**                                | **✅ 文本头部（未压缩）**                                               | **✅**HPACK 压缩**（二进制）                      | **✅**QPACK 压缩**（动态表）            |
| **数据传输**     | **❌ 仅文本（无类型/长度）** | **✅ 支持二进制（**`Content-Type`）                    | **✅ 支持分块传输（**`Transfer-Encoding: chunked`）                   | **✅ 二进制帧（**`DATA`帧）                       | **✅ 二进制帧（**`STREAM`帧）           |
| **关键性能优化** | **-**                        | **-**                                                    | **🔹 管道化（易队头阻塞） 🔹 缓存控制（**`Cache-Control`）            | **🔹**多路复用**🔹 服务器推送（`PUSH_PROMISE`） | **🔹**0-RTT 快速握手**🔹 改进的丢包恢复 |
| **队头阻塞问题** | **❌ 无（单请求）**          | **❌ 无（串行）**                                        | **🔴**存在**（响应必须顺序返回）                                      | **🔴**TCP 层队头阻塞**                            | **✅**彻底解决**（QUIC 流隔离）         |
| **安全性**       | **❌ 无加密**                | **❌ 无强制加密**                                        | **❌ 无强制加密**                                                       | **⚠️ 事实需 HTTPS（浏览器强制）**                 | **✅**内置 TLS 1.3**                    |
| **握手延迟**     | **1× RTT（TCP）**           | **1× RTT（TCP）**                                       | **1× RTT（TCP）**                                                      | **1~3× RTT（TCP+TLS）**                            | **✅**0~1× RTT**（QUIC 0-RTT）         |
| **典型请求示例** | `GET /page`                      | `<br>GET /page HTTP/1.0<br>Host: example.com<br>`            | `<br>GET /page HTTP/1.1<br>Host: example.com<br>Connection: keep-alive<br>` | **二进制帧（含流ID、头部块等）**                    | **QUIC 数据包（含连接ID、流ID）**         |
| **核心缺陷**     | **功能极简**                 | **连接开销大**                                           | **队头阻塞 + 头部冗余**                                                 | **TCP 队头阻塞**                                    | **部署复杂度高**                          |

---

### 关键特性详解

#### 1. **HTTP/1.1 核心改进**

* **持久连接**：复用 TCP 连接（省去重复握手开销）。
* **管道化（Pipelining）**：允许连续发送多个请求（但响应必须按序返回 → **队头阻塞**）。
* **分块传输**：支持流式大数据传输（`Transfer-Encoding: chunked`）。
* **缓存控制**：`Cache-Control`、`ETag` 等精细化缓存策略。

#### 2. **HTTP/2 革命性突破**

* **二进制分帧层**：
  * **将消息拆分为 **HEADERS 帧**和 **DATA 帧**，通过**流标识符（Stream ID）** 重组。
* **多路复用（Multiplexing）**：
  * **单 TCP 连接上并行传输多个流，解决 HTTP/1.1 并发限制。**
* **头部压缩（HPACK）**：
  * **静态霍夫曼编码 + 动态表减少头部冗余（尤其 Cookie）。**
* **服务器推送（Server Push）**：
  * **主动推送关联资源（如 CSS/JS）减少客户端请求。**

#### 3. **HTTP/3 的底层革新**

* **QUIC 协议取代 TCP**：
  * **基于 UDP 实现可靠传输，内置加密（TLS 1.3）和拥塞控制。**
* **连接迁移**：
  * **切换网络时（WiFi→4G）**连接 ID 不变**，无需重新握手。
* **零 RTT 建连**：
  * **首次访问 1-RTT，后续访问 0-RTT（类似 TLS 会话恢复）。**
* **彻底解决队头阻塞**：
  * **QUIC 的流（Stream）独立传输，丢包只影响当前**

**HTTP/3 基于 UDP 实现可靠传输的核心技术是 **QUIC 协议**（Quick UDP Internet Connections）。QUIC 在 UDP 之上重建了可靠性机制，同时融合了 TCP 和 TLS 的优点。以下是其实现可靠传输的关键技术：

---

### 一、QUIC 的核心可靠性机制

#### 1. **数据包编号机制**

* **单调递增的 Packet Number**：
  * **每个数据包都有唯一递增编号（不同于 TCP 序列号）**
  * **解决 TCP 重传歧义问题（重传包使用新编号）**
* **示例**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1159" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">初始发送：Packet #1, #2, #3</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">丢包重传：重传的包变为 Packet #4（而非复用旧编号）</span></pre></div></div></div></div></div><div></div></div></div></pre>

#### 2. **改进的确认机制**

* **ACK 帧带延迟信息**：
  * **携带精确的接收时间戳（用于 RTT 计算）**
  * **支持**选择性确认（SACK）**，明确告知丢失范围
* **显式丢包通知**：
  * **通过 NACK（Negative ACK）快速报告丢包**

#### 3. **前向纠错（FEC）**

* **发送冗余的 FEC 包（异或校验包）**
* **丢失单个包时可通过其他包+FEC包重建数据**
* **减少小规模丢包时的重传**

---

### 二、连接管理机制

#### 1. **连接迁移**

* **Connection ID 标识连接**
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1188" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">// 连接标识（IP变化时仍有效）</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">connection_id = 0x8a4f3b2c</span></pre></div></div></div></div></div><div></div></div></div></pre>
* **当客户端 IP 改变（如 WiFi 切 4G），TCP 需重建连接，QUIC 保持连接**

#### 2. **0-RTT 快速重启**

* **基于 TLS 1.3 的会话恢复**
* **之前连接过的客户端可在首次包中携带数据**

---

### 三、多路复用与流控制

#### 1. **流（Stream）隔离**

* **单个 QUIC 连接支持多个独立 Stream**
* **关键优势**：一个 Stream 丢包不影响其他 Stream（解决 TCP 队头阻塞）

#### 2. **分级流量控制**

* **两层控制：**
  1. **连接级控制**（总带宽限制）
  2. **流级控制**（每个流的独立窗口）
* **动态窗口调整算法**
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1216" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">// 伪代码：窗口增长逻辑</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">if (no_loss_event) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    window_size *= 1.5; // 指数增长</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">} else {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    window_size *= 0.7; // 乘性减少</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">}</span></pre></div></div></div></div></div><div></div></div></div></pre>

---

### 四、安全与拥塞控制

#### 1. **深度集成加密**

* **头部加密**：连包类型都加密（防中间设备干扰）
* **认证加密**：使用 AES-GCM/ChaCha20-Poly1305
* **密钥轮换**：每个包使用不同密钥

#### 2. **智能拥塞控制**

* **可插拔算法**：
  * **默认使用 **Cubic**（类似 TCP）
  * **可选 **BBR**（Google 的 Bottleneck Bandwidth and RTT）
* **带宽预测模型**：**
  **BDP=Bmax×RTTmin*B**D**P*=*B**ma**x*×*RT**T**min***
  **（BDP：带宽延迟积，决定最优窗口大小）

---

### 五、QUIC vs TCP 可靠性对比

| **特性**     | **TCP**              | **QUIC over UDP**       |
| ------------------ | -------------------------- | ----------------------------- |
| **握手延迟** | **3-RTT（TCP+TLS）** | **1-RTT（0-RTT 可选）** |
| **队头阻塞** | **有（单流阻塞）**   | **无（多流隔离）**      |
| **重传歧义** | **有（相同序列号）** | **无（唯一递增包号）**  |
| **连接迁移** | **不支持**           | **原生支持**            |
| **前向纠错** | **无**               | **可选支持**            |
| **加密范围** | **仅加密负载**       | **加密头部+负载**       |

---

### 六、典型数据传输流程

**以文件下载为例：**

1. **连接建立**
   <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1275" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Client → Server: Client Hello (携带 0-RTT 数据)</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Server → Client: Server Hello + ACK</span></pre></div></div></div></div></div><div></div></div></div></pre>
2. **数据传输**：
   <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1278" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Client: 发送 Stream1 数据包#1-#10</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Server: 收到 #1,#3-#10 → 回复 ACK(范围) + NACK(#2)</span></pre></div></div></div></div></div><div></div></div></div></pre>
3. **丢包恢复**：
   * **选项1：快速重传（收到3个重复ACK后立即重传#2）**
   * **选项2：FEC重建（若配置了前向纠错）**
4. **拥塞响应**：
   * **检测到丢包 → 窗口减半**
   * **持续无丢包 → 窗口指数增长**

---

### 七、技术挑战与解决方案

| **挑战**              | **QUIC 解决方案**                |
| --------------------------- | -------------------------------------- |
| **UDP 不可靠**        | **自定义ACK/NACK+重传**          |
| **NAT 防火墙阻挡UDP** | **回落TCP（HTTP/2备用）**        |
| **中间设备干扰UDP**   | **加密所有头部信息**             |
| **操作系统内核限制**  | **用户空间实现（无需内核升级）** |
| **移动网络切换断连**  | **Connection ID 保持连接**       |

---

### 总结

**HTTP/3 通过 QUIC 在 UDP 上实现可靠传输的关键是：**

1. **重建可靠性基础**：包编号、ACK/NACK、重传
2. **创新设计**：流隔离、连接迁移、0-RTT
3. **深度安全集成**：全加密、密钥轮换
4. **灵活拥塞控制**：可插拔算法、带宽预测

**这使得 QUIC 在保留 UDP 高效性的同时，获得了比 TCP 更优的可靠性和性能，尤其在高丢包、移动网络环境下表现显著提升。**

# HTTPS

**HTTPS = HTTP + TLS/SSL，通过**加密传输**和**身份认证**保障安全。以下是完整连接过程（以 TLS 1.3 简化流程为例）：

---

### **HTTPS 连接建立流程**

#### **阶段 1：TCP 三次握手**（基础连接）

1. **客户端 → 服务器：**`SYN`
2. **服务器 → 客户端：**`SYN + ACK`
3. **客户端 → 服务器：**`ACK`
   **✅ **此时建立 TCP 连接（未加密）**

---

#### **阶段 2：TLS 握手**（核心安全层）

##### **步骤 1：Client Hello**

* **客户端发送：**
  * **支持的 TLS 版本**
  * **客户端随机数（Client Random）**
  * **支持的加密套件列表（如 **`TLS_AES_128_GCM_SHA256`）

##### **步骤 2：Server Hello**

* **服务器响应：**
  * **选定的 TLS 版本**
  * **服务器随机数（Server Random）**
  * **选定的加密套件**
  * **服务器证书链**（含公钥、域名、CA 签名）

##### **步骤 3：证书验证**（关键安全步骤）

1. **客户端验证证书：**
   * **检查域名是否匹配**
   * **检查有效期**
   * **验证 CA 签名链**（详见下方 CA 验证机制）
   * **查询 OCSP 或 CRL 确认未吊销**

##### **步骤 4：密钥交换**

* **非对称加密阶段**（仅此阶段使用）：
  * **客户端生成 **Pre-Master Secret**
  * **用**服务器证书公钥**加密后发送 → 服务器
* **服务器用**私钥解密**获取 Pre-Master Secret

##### **步骤 5：生成会话密钥**

* **双方通过以下参数生成**对称会话密钥**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1393" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Master Secret = PRF(Client Random + Server Random + Pre-Master Secret)  </span></pre></div></div></div></div></div></div><div></div></div></div></pre>
* **✅ **会话密钥用于后续对称加密**

##### **步骤 6：完成握手**

* **双方发送 **`Finished` 消息（用会话密钥加密）
* **验证握手完整性**

---

#### **阶段 3：加密数据传输**

* **对称加密阶段**（高效加密）：
  * **所有 HTTP 数据被拆分为 **TLS Record**
  * **使用会话密钥进行 AES/GCM 加密传输**
  * **示例：**
    <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1414" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">[加密后] 2F 8A 01 9C... → 传输 → 服务器解密为 "GET /index.html HTTP/1.1"  </span></pre></div></div></div></div></div></div><div></div></div></div></pre>

---

### CA 证书验证机制

**证书验证是防范中间人攻击的核心：**

1. **证书链校验**：
   * **服务器证书 → 中间 CA 证书 → 根 CA 证书**
   * **客户端用**本地信任的根 CA 公钥**验证签名链
2. **吊销检查**：
   * **OCSP（在线证书状态协议）**：实时查询证书状态
   * **CRL（证书吊销列表）**：定期下载黑名单
3. **扩展验证**：
   * **EV 证书验证组织真实性（显示绿色企业名称）**

---

### 无响应时的处理策略

**TLS 协议内置超时重传机制：**

| **场景**                | **处理方式**                                    | **超时时间**            |
| ----------------------------- | ----------------------------------------------------- | ----------------------------- |
| **Client Hello 无响应** | **客户端重发（指数退避算法）**                  | **初始 1s → 最大 60s** |
| **握手中途失败**        | **关闭连接并触发** `TLS Handshake Failed`错误 | **TCP 层决定**          |
| **应用数据传输超时**    | **TCP 重传机制触发**                            | **动态 RTO 计算**       |

---

### 防范中间人攻击（MitM）措施

**HTTPS 通过四重机制防御：**

1. **证书签名体系**：
   * **攻击者无法伪造 CA 签名的合法证书（除非控制根 CA）**
2. **公钥绑定**：
   * **浏览器强制检查证书域名（HSTS 可阻止降级攻击）**
3. **密钥交换保密**：
   * **Pre-Master Secret 用**服务器公钥加密**，仅私钥持有者可解密
4. **双向认证（可选）**：
   * **服务器要求客户端提供证书（用于银行等高安全场景）**

**经典 MitM 攻击失败原因**：**
**攻击者截获流量时：

* **若提供**自签名证书** → 浏览器显示 `NET::ERR_CERT_AUTHORITY_INVALID`
* **若提供**盗用证书** → 私钥不在攻击者手中，无法解密 Pre-Master Secret

---

### 加密技术总结

| **阶段**         | **加密类型**   | **算法示例**                 | **作用**                       |
| ---------------------- | -------------------- | ---------------------------------- | ------------------------------------ |
| **证书公钥传输** | **非对称加密** | **RSA 2048 / ECC secp256r1** | **安全传递 Pre-Master Secret** |
| **会话密钥生成** | **密钥协商**   | **ECDHE / DHE**              | **前向保密保障**               |
| **应用数据传输** | **对称加密**   | **AES-128-GCM / ChaCha20**   | **高效加密实际内容**           |

---

### 核心安全设计思想

1. **非对称加密建立信任** → 解决密钥分发问题
2. **对称加密高效通信** → 解决性能瓶颈
3. **PKI 体系验证身份** → 防范中间人攻击
4. **前向保密（PFS）** → 即使私钥泄露，历史会话仍安全

**通过以上机制，HTTPS 在开放网络中构建了机密性、完整性和身份认证三大安全支柱。**

## 与浏览器相关

### **1. 渲染进程（Renderer Process） - 请求发起**

* **触发位置**：Blink渲染引擎（如V8执行JavaScript）
* **关键操作**：
  * **解析HTML中的** `<a>`、`<img>`等资源标签
  * **执行JavaScript中的** `fetch()`或 `XMLHttpRequest`
  * **生成**HTTP请求头**（包含URL、Method、Cookie等）
* **协议栈入口**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="js" cid="n1542" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 示例：JS发起请求</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">fetch</span>(<span class="cm-string">'https://api.example.com/data'</span>, {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-property">method</span>: <span class="cm-string">'POST'</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-property">headers</span>: {<span class="cm-string cm-property">'Content-Type'</span>: <span class="cm-string">'application/json'</span>},</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-property">body</span>: <span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>({<span class="cm-property">key</span>: <span class="cm-string">'value'</span>})</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">});</span></pre></div></div></div></div></div><div></div></div></div></pre>
* **跨进程通信**：通过**Mojo IPC**将请求发送给网络进程

### **2. 网络进程（Network Service） - 协议栈核心**

* **核心组件**：
  * **HTTP/HTTP2栈**：处理应用层协议
  * **QUIC实现**：基于UDP的HTTP/3
  * **TLS/SSL引擎**：加密解密
  * **TCP/UDP套接字管理**
* **协议处理流程**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1560" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">┌─────────────────────┐</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 接收渲染进程请求     │</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 1. 检查缓存         │ → MemoryCache/DiskCache</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 2. 解析URL          │ → 提取协议/主机/端口</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 3. 处理HTTP语义     │ → 添加Cookie/UA/Referer</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 4. TLS握手协商      │ → RSA/ECDHE密钥交换</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 5. TCP连接管理      │ → 复用连接或三次握手</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 6. 数据分帧发送      │ → HTTP/2二进制分帧</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 7. 接收响应         │ → 处理重定向/压缩</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 8. 流式传输给渲染进程│ ← 通过IPC管道</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">└─────────────────────┘</span></pre></div></div></div></div></div><div></div></div></div></pre>

### **3. 浏览器进程（Browser Process） - 全局管控**

* **关键职责**：
  * **Cookie管理**：通过CookieStore访问存储
  * **证书验证**：调用系统证书库
  * **代理配置**：应用PAC脚本或系统代理
  * **安全策略**：CORS预检、HSTS强制HTTPS
  * **网络隔离**：实施Site Isolation策略
* **跨域处理示例**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1578" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">渲染进程 → 请求api.other.com</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">网络进程 → 触发CORS预检OPTIONS请求</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">浏览器进程 → 验证跨域策略</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">网络进程 → 转发实际请求</span></pre></div></div></div></div></div><div></div></div></div></pre>

### **4. 操作系统内核 - 底层协议执行**

* **TCP/IP栈**：内核处理三次握手、拥塞控制
* **套接字操作**：
  
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="c" cid="n1585" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 伪代码：网络进程调用系统API</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable-3">int</span> <span class="cm-variable">sockfd</span> <span class="cm-operator">=</span> <span class="cm-variable">socket</span>(<span class="cm-variable">AF_INET</span>, <span class="cm-variable">SOCK_STREAM</span>, <span class="cm-number">0</span>); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">connect</span>(<span class="cm-variable">sockfd</span>, (<span class="cm-keyword">struct</span> <span class="cm-def">sockaddr</span><span class="cm-operator">*</span>)<span class="cm-operator">&</span><span class="cm-variable">serv_addr</span>, <span class="cm-keyword">sizeof</span>(<span class="cm-variable">serv_addr</span>));</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">write</span>(<span class="cm-variable">sockfd</span>, <span class="cm-variable">http_request</span>, <span class="cm-variable">strlen</span>(<span class="cm-variable">http_request</span>));</span></pre></div></div></div></div></div><div></div></div></div></pre>
