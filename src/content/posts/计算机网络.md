---
title: 计算机网络
published: 2026-02-14
description: '计算机网络'
image: ''
tags: []
category: ''
draft: false 
lang: 'zh-cn'
---

# 计算机网络模型

## OSI七层模型

`ISO`为了更好的使网络应用更为普及，推出了 `OSI`参考模型。

![img](./img/25037.jpg)

#### 应用层

`OSI`参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：`HTTP`，`HTTPS`，`FTP`，`POP3`、`SMTP`等。

* **在客户端与服务器中经常会有数据的请求，这个时候就是会用到** `http(hyper text transfer protocol)(超文本传输协议)`或者 `https`在后端设计数据接口时，我们常常使用到这个协议。
* `FTP`是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如 `百度网盘、迅雷`应该是基于此协议的。
* `SMTP`是 `simple mail transfer protocol（简单邮件传输协议）`。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。

#### 表示层

**表示层提供各种用于** **应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别**。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。

**在项目开发中，为了方便数据传输，可以使用** `base64`对数据进行编解码。如果按功能来划分，`base64`应该是工作在表示层。

#### 会话层

**会话层就是** **负责建立、管理和终止表示层实体之间的通信会话**。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。

#### 传输层

**传输层建立了** **主机端到端的链接**，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，`TCP``UDP`就是在这一层。端口号既是这里的“端”。

#### 网络层

**本层通过** `IP`寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的 `IP`层。这一层就是我们经常说的 `IP`协议层。`IP`协议是 `Internet`的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。

#### 数据链路层

**将比特组合成字节,再将** **字节组合成帧,**使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。

**网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。**

#### 物理层

**实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。**

**OSI七层模型通信特点：对等通信**

**对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。**

#### 数据传输

![image-20250628113806329](./img/bf34a01c9faf2dffc49a31e63858804.png)

| **OSI层**      | **PDU名称**   | **组成说明**                                                       |
| -------------------- | ------------------- | ------------------------------------------------------------------------ |
| **应用层**     | **报文/消息** | **用户数据（如HTTP请求、FTP文件）**                                |
| **表示层**     | **报文**      | **加密/压缩后的数据（如SSL/TLS加密的HTTP数据）**                   |
| **会话层**     | **报文**      | **建立/维护会话的数据（如RPC调用、NetBIOS会话）**                  |
| **传输层**     | **段**        | **TCP/UDP数据，添加端口号、校验和（如TCP段包含序列号、窗口大小）** |
| **网络层**     | **包**        | **IP数据包，包含源/目的IP地址（如IPv4包）**                        |
| **数据链路层** | **帧**        | **以太网帧，添加MAC地址、CRC校验（如Ethernet II帧）**              |
| **物理层**     | **比特流**    | **二进制信号（如电脉冲、光信号）**                                 |

**PDU的封装与解封装过程**
**数据在发送时从上到下逐层封装，接收时从下到上逐层解封装：**

**发送方（封装流程）**

* **应用层生成原始数据（如HTTP请求）。**
* **传输层（TCP/UDP）添加端口号、校验和，形成Segment。**
* **网络层（IP）添加源/目的IP地址，形成Packet。**
* **数据链路层（以太网）添加MAC地址、帧头/尾，形成Frame。**

**物理层将帧转为比特流，通过介质传输。**

* **接收方（解封装流程）物理层接收比特流，还原为帧。**
* **数据链路层校验帧，去除MAC头，提取Packet。**
* **网络层检查IP地址，去除IP头，提取Segment。**
* **传输层验证端口和校验和，去除TCP/UDP头，传递数据给应用层。**

**关键点**
**每层只处理本层的PDU**

**例如，路由器（网络层设备）只处理IP包，不关心TCP段或以太网帧的内容,交换机（数据链路层设备）只处理MAC帧，不解析IP包。**

**PDU的命名差异**

* **TCP/IP模型中：**
* **网络接口层PDU称Frame（帧）。**
* **互联网层（IP）PDU称Packet（包）。**
* **传输层（TCP/UDP）PDU仍称Segment（段）。**

**封装开销**

**每层添加的头部/尾部会增加传输开销（如以太网帧头14字节，IP头20字节，TCP头20字节）。**

##### 实例分析（HTTP over TCP/IP）

**假设用户访问一个网页，PDU变化如下：**

* **应用层：HTTP请求（GET /index.html） → Message。**
* **传输层：添加TCP头（源端口、目的端口80） → Segment。**
* **网络层：添加IP头（源IP 192.168.1.2，目的IP 93.184.216.34） → Packet。**
* **数据链路层：添加以太网头（源MAC 00:1A:2B:3C:4D:5E，目的MAC 网关MAC） → Frame。**
* **物理层：转为比特流发送。**

## Linux 接收网络包的流程

**网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。**

### 告诉操作系统网络包已到达

**那应该怎么告诉操作系统这个网络包已经到达了呢？**

**最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。**

**但是，这存在一个问题，在高性能网络场景下，网络包的数量会非常多，那么就会触发非常多的中断，要知道当 CPU 收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么频繁地触发中断，则会导致 CPU 一直没完没了的处理中断，而导致其他任务可能无法继续前进，从而影响系统的整体效率。**

**所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了** **NAPI 机制**，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是**不采用中断的方式读取数据**，而是首先采用中断唤醒数据接收的服务程序，然后 poll 的方法来轮询数据。

**因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。**

**硬件中断处理函数会做如下的事情：**

* **需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。**
* **接着，发起「软中断」，然后恢复刚才屏蔽的中断。**

**至此，硬件中断处理函数的工作就已经完成。**

**硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。**

### 软中断的处理

**内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。**

**ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 **`sk_buff` 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。

### 网络协议栈

**首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。**

**到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。**

**传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。**

**最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。**

**至此，一个网络包的接收过程就已经结束了。下图左边部分描述的就是网络包接收的流程，右边部分刚好反过来，它是网络包发送的流程。**

![网络包接收和发送流程](./img/receive-and-send-network-packets.d585a7bd.png)

## Linux 发送网络包的流程

**如上图的右半部分，发送网络包的流程正好和接收流程相反。**

### 应用层

**首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 **`sk_buff` 内存，** **将用户待发送的数据拷贝到 `sk_buff` 内存，并将其加入到发送缓冲区**。

### 传输层

**接下来，网络协议栈从 Socket 发送缓冲区中取出 **`sk_buff`，并按照 TCP/IP 协议栈从上到下逐层处理。

**如果使用的是 TCP 传输协议发送数据，那么** **先拷贝一个新的 `sk_buff` 副本**，这是因为 `sk_buff` 后续在调用网络层，最后到达网卡发送完成的时候，这个 `sk_buff` 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 `sk_buff` 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 `sk_buff` 的一个拷贝，等收到 ACK 再真正删除。

**接着，对 **`sk_buff` 填充 TCP 头。这里提一下，`sk_buff` 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment（段），在 IP 层我们叫 packet（包），在数据链路层称为 frame（帧）。

**你可能会好奇，为什么全部数据包只用一个结构体来描述呢？协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低 CPU 效率。**

**于是，为了在层级之间传递数据时，不发生拷贝，只用 **`sk_buff` 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 `sk_buff` 中 data 的指针，比如：

* **当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb -> data 的值，来逐步剥离协议首部。**
* **当要发送报文时，创建 **`sk_buff` 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb -> data 的值来增加协议首部。

**至此，传输层的工作也就都完成了。**

### 网络层

**然后交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。**

### 网络接口层

**网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 **`sk_buff` 填充帧头和帧尾，接着将 `sk_buff` 放到网卡的发送队列中。

### 通知网卡有包要发送

**这一些工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 **`sk_buff`，将这个 `sk_buff` 挂到 RingBuffer 中，接着将 `sk_buff` 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。

### 完成网络包的发送

**当数据发送完成以后，其实工作并没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放 **`sk_buff` 内存和清理 RingBuffer 内存。

**最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 **`sk_buff` 。

**发送网络数据的时候，涉及几次内存拷贝操作？**

* **第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 **`sk_buff` 内存，将用户待发送的数据拷贝到 `sk_buff` 内存，并将其加入到发送缓冲区。
* **第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 **`sk_buff` 都会被克隆一个新的副本出来。副本 `sk_buff` 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 `sk_buff` 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 `sk_buff`。
* **第三次，当 IP 层发现 **`sk_buff` 大于 MTU 时才需要进行。会再申请额外的 `sk_buff`，并将原来的 `sk_buff` 拷贝为多个小的 `sk_buff`。

### **总结**

**电脑与电脑之间通常都是通过话网卡、交换机、路由器等网络设备连接到一起，那由于网络设备的异构性，国际标准化组织定义了一个七层的 OSI 网络模型，但是这个模型由于比较复杂，实际应用中并没有采用，而是采用了更为简化的 TCP/IP 模型，Linux 网络协议栈就是按照了该模型来实现的。**

**TCP/IP 模型主要分为应用层、传输层、网络层、网络接口层四层，每一层负责的职责都不同，这也是 Linux 网络协议栈主要构成部分。**

**当应用程序通过 Socket 接口发送数据包，数据包会被网络协议栈从上到下进行逐层处理后，才会被送到网卡队列中，随后由网卡将网络包发送出去。**

**而在接收网络包时，同样也要先经过网络协议栈从下到上的逐层处理，最后才会被送到应用程序。**

**在网上看到一张不错的动图，附上：**

![OSI 七层协议数据传输的封包与解包过程](./img/receive-and-send-network-packets-in-osi.70a653a6.gif)

**各层协议与设备**
![](./img/16ce7eb72c0dc44c.webp)

![](./img/16ce7ee86d166933.webp)

# IP

## IP协议的基本功能

**IP的主要目的是通过一个互联的网络传输数据报，涉及两个最基本的功能。**

* **寻址（Addressing）**：IP协议根据数据报首部中包括的目的地址将数据报传送到目的节点，这就要涉及传送路径的选择，即路由功能。IP协议使用IP地址来实现路由。
* **分片（Fragmentation）**：IP协议还提供对数据大小的分片和重组，以适应不同网络对数据包大小的限制。如果网络只能传送小数据包，IP协议将对数据报进行分段并重新组成小块再进行传送

## IP协议的特性

**IP 是一个** **无连接的、不可靠的、点对点** 的协议，只能尽力（Best Effort）传送数据，不能保证数据的到达。

**在IP网络中，“点对点”（Point-to-Point，简称P2P）指** **两个网络节点之间建立直接、独占的通信链路**

**具体地讲，主要有以下特性。**

* **IP协议提供无连接数据报服务，各个数据报独立传输，可能沿着不同的路径到达目的地，也可能不会按序到达目的地。**
* **IP 协议不含错误检测或错误恢复的编码，属于不可靠的协议。所谓不可靠，是从数据传输的可靠性不能保证的角度而言的，查询的延误及其他网络通信故障都有可能导致所传数据的丢失。对这种情况，IP 协议本身不处理。它的不可靠并不能说明整个 TCP/IP 协议不可靠。如果要求数据传输具有可靠性，则要在IP的上面使用TCP协议加以保证。位于上一层的TCP协议则提供了错误检测和恢复机制。**
* **作为一种点对点协议，虽然 IP 数据报携带源 IP 地址和目的 IP 地址，但进行数据传输时的对等实体一定是相邻设备（同一网络）中的对等实体。**
* **IP协议的效率非常高，实现起来也较简单。这是因为IP协议采用了尽力传输的思想，随着底层网络质量的日益提高，IP协议的尽力传输的优势体现得更加明显。**

## IP协议的工作方式

**在一个路由式网络中，源地址主机向目标地址主机发送数据时，IP协议是如何将数据成功发送到目标主机上的呢？由于网络分同网段和不同网段两种情况，工作方式如下：**

### 同网段

**如果源地址主机和目标地址主机在同一网段，目标IP地址被ARP协议解析为MAC地址，然后根据MAC地址，源主机直接把数据包发给目标主机。**

### 不同网段

**如果源地址主机和目标地址主机在不同网段，数据包发送过程如下：**

**（1）网关（一般为路由器）的IP地址被ARP协议解析为MAC地址。根据该MAC地址，源主机将数据包发送到网关。**

**（2）网关根据数据包中的网段ID寻找目标网络。如果找到，将数据包发送到目标网段；如果没找到，重复步骤（1）将数据包发送到上一级网关。**

**（3）数据包经过网关被发送到正确的网段中。目标IP地址被ARP协议解析为MAC地址。根据该MAC地址，数据包被发送给目标地址的主机。**

## **ip地址分类**

* **A类地址：范围从0.0.0.0到127.255.255.255，默认子网掩码为255.0.0.0，适用于大型网络。**
* **B类地址：范围从128.0.0.0到191.255.255.255，默认子网掩码为255.255.0.0，适用于中型网络。**
* **C类地址：范围从192.0.0.0到223.255.255.255，默认子网掩码为255.255.255.0，适用于小型网络。**
* **D类地址：范围从224.0.0.0到239.255.255.255，用于多播地址。**
* **E类地址：范围从240.0.0.0到255.255.255.255，保留用于实验和研究。**

![](./img/21928.jpg)

# TCP、UDP

## TCP 和 UDP的概念及特点

**TCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族：**

**（1）UDP**

**UDP的全称是** **用户数据报协议**，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。

**它的特点如下：**

**1）面向无连接**

**首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。**

**具体来说就是：**

* **在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了**
* **在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作**

**2）有单播，多播，广播的功能**

**UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。**

**3）面向报文**

**发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文**

**4）不可靠性**

**首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。**

**并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。**

**再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。**

**5）头部开销小，传输数据报文时是很高效的。**

![img](./img/2019-03-21-03.png)

**UDP 头部包含了以下几个数据：**

* **两个十六位的端口号，分别为源端口（可选字段）和目标端口**
* **整个数据报文的长度**
* **整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误**

**因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。**

**（2）TCP**

**TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。**

**它有以下几个特点：**

**1）面向连接**

**面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。**

**2）仅支持单播传输**

**每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。**

**3）面向字节流**

**TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。**

**4）可靠传输**

**对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。**

**5）提供拥塞控制**

**当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。**

**6）提供全双工通信**

**TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）**

## TCP和UDP的区别

|                        | **UDP**                                        | **TCP**                                                  |
| ---------------------- | ---------------------------------------------------- | -------------------------------------------------------------- |
| **是否连接**     | **无连接**                                     | **面向连接**                                             |
| **是否可靠**     | **不可靠传输，不使用流量控制和拥塞控制**       | **可靠传输（数据顺序和正确性），使用流量控制和拥塞控制** |
| **连接对象个数** | **支持一对一，一对多，多对一和多对多交互通信** | **只能是一对一通信**                                     |
| **传输方式**     | **面向报文**                                   | **面向字节流**                                           |
| **首部开销**     | **首部开销小，仅8字节**                        | **首部最小20字节，最大60字节**                           |
| **适用场景**     | **适用于实时应用，例如视频会议、直播**         | **适用于要求可靠传输的应用，例如文件传输**               |

## TCP和UDP的使用场景

* **TCP应用场景：** 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
* **UDP应用场景：** 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。

## UDP协议为什么不可靠？

**UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：**

* **不保证消息交付：不确认，不重传，无超时**
* **不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞**
* **不跟踪连接状态：不必建立连接或重启状态机**
* **不进行拥塞控制：不内置客户端或网络反馈机制**

## TCP

### 三次握手

![img](./img/850de5c566ae60989f45cff4b1aad94c.png)

**三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。**

**刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。**

* **第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。**

**首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。**

* **第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。**

**在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y**

* **第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。**

**确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。**

**那为什么要三次握手呢？两次不行吗？**

* **为了确认双方的接收能力和发送能力都正常**
* **如果是用两次握手，则会出现下面这种情况：**

**如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。**

#### 第一次握手丢失了，会发生什么？

**当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 **`SYN_SENT` 状态。

**在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「**超时重传**」机制，重传 SYN 报文，而且**重传的 SYN 报文的序列号都是一样的**。

**对于超时时间，不同版本的操作系统可能不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。**

**当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？**

**在 Linux 里，客户端的 SYN 报文最大重传次数由 **`tcp_syn_retries` 内核参数控制，这个参数是可以自定义的，默认值一般是 5。

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n369" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># cat /proc/sys/net/ipv4/tcp_syn_retries</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-number">5</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

**通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，**每次超时的时间是上一次的 2 倍**。

**当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。**

**所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。**

**举个例子，假设 **`tcp_syn_retries` 参数值为 3，那么当客户端的 SYN 报文一直在网络中丢失时，会发生下图的过程：

![第一次握手丢失](./img/lost-in-first-handshake.b62af538.png)

**（第一次握手丢失）**

**具体过程：**

* **当客户端超时重传 3 次 SYN 报文后，由于 **`tcp_syn_retries` 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。

#### 第二次握手丢失了，会发生什么？

**当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 **`SYN_RCVD` 状态。

**第二次握手的 SYN-ACK 报文其实有两个目的：**

* **第二次握手里的 ACK， 是对第一次握手的确认报文；**
* **第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；**

**所以，如果第二次握手丢了，就会发生比较有意思的事情，具体会怎么样呢？**

**因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是**客户端就会触发超时重传机制，重传 SYN 报文**。

**然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。**

**那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 SYN-ACK 报文。**

**因此，当第二次握手丢失了，** **客户端和服务端都会重传**：

* **客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 **`tcp_syn_retries` 内核参数决定；
* **服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 **`tcp_synack_retries` 内核参数决定。

**在 Linux 下，SYN-ACK 报文的最大重传次数由 **`tcp_synack_retries` 内核参数决定，默认值是 5。

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n399" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment"># cat /proc/sys/net/ipv4/tcp_synack_retries</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-number">5</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

**举个例子，假设 **`tcp_syn_retries` 参数值为 1，`tcp_synack_retries` 参数值为 2，那么当第二次握手一直丢失时，发生的过程如下图：

![第二次握手丢失](./img/lost-in-second-handshake.1e63a9ff.png)

**具体过程：**

* **当客户端超时重传 1 次 SYN 报文后，由于 **`tcp_syn_retries` 为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。
* **当服务端超时重传 2 次 SYN-ACK 报文后，由于 **`tcp_synack_retries` 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。

#### 第三次握手丢失了，会发生什么？

**客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 **`ESTABLISH` 状态。

**因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。**

**注意，** **ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**。

**举个例子，假设 **`tcp_synack_retries` 参数值为 2，那么当第三次握手一直丢失时，发生的过程如下图：

![第三次握手丢失](./img/lost-in-third-handshake.7f728e63.png)

**具体过程：**

* **当服务端超时重传 2 次 SYN-ACK 报文后，由于 **`tcp_synack_retries` 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。

#### 关于 SYN 攻击

##### 什么是 SYN 攻击

**我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 **`SYN` 报文**，服务端每接收到一个 `SYN` 报文，就进入 `SYN_RCVD` 状态，但服务端发送出去的 `SYN-ACK` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会 **占满服务端的半连接队列**，使得服务器不能为正常用户服务。

![SYN 攻击](./img/syn-attack.23a59005.png)

**下面先来看一下什么是 TCP 半连接和全连接队列。**

##### 半连接和全连接队列

**在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：**

* **半连接队列，也称 SYN 队列。**
* **全连接队列，也称 Accpet 队列。**

**先来看下 Linux 内核的 **`SYN` 队列（半连接队列）与 `Accpet` 队列（全连接队列）是如何工作的？

![SYN 攻击](./img/syn-queue-and-accpet-queue-1.61cea3b1.png)

**正常流程：**

* **当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「SYN 队列」。**
* **接着发送 SYN-ACK 给客户端，等待客户端回应 ACK 报文。**
* **服务端接收到 ACK 报文后，从「SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「Accept 队列」。**
* **应用通过调用 **`accpet()` socket 接口，从「Accept 队列」取出连接对象。

**不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。**

**SYN 攻击方式最直接的表现就是把 TCP 半连接队列打满，这样**当 TCP 半连接队列满了，后续再收到 SYN 报文就会丢弃**，导致客户端无法和服务端建立连接。

#### 避免 SYN 攻击方式

**避免 SYN 攻击方式，可以有以下四种方法：**

* **调大 **`netdev_max_backlog`
* **增大 TCP 半连接队列**
* **开启 **`tcp_syncookies`
* **减少 SYN-ACK 重传次数**

##### 1）方式一：调大 `netdev_max_backlog`

**当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数，默认值是 1000，我们要适当调大该参数的值，比如设置为 10000：**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n460" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">net.core.netdev_max_backlog <span class="cm-operator">=</span> <span class="cm-number">10000</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

##### 2）方式二：增大 TCP 半连接队列

**增大 TCP 半连接队列，要同时增大下面这三个参数：**

* **增大 **`net.ipv4.tcp_max_syn_backlog`
* **增大 **`listen()` 函数中的 `backlog`
* **增大 **`net.core.somaxconn`

**具体为什么是这三个参数决定 TCP 半连接队列的大小，这里暂不深入研究。**

##### 3）方式三：开启 `net.ipv4.tcp_syncookies`

**开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。**

![SYN 队列占满，启动 cookie](./img/syn-queue-and-accpet-queue-2.65bc64b2.png)

**具体过程：**

* **当「SYN 队列」满之后，后续服务器收到 SYN 包，不会丢弃，而是根据算法，计算出一个 cookie 值。**
* **将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端。**
* **服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「Accept 队列」。**
* **最后应用程序通过调用 **`accpet()` 接口，从「Accept 队列」取出的连接。

**可以看到，当开启了 **`tcp_syncookies` 了，即使受到 SYN 攻击而导致 SYN 队列满时，也能保证正常的连接成功建立。

`net.ipv4.tcp_syncookies` 参数主要有以下三个值：

* `0` 值，表示关闭该功能。
* `1` 值，表示仅当 SYN 半连接队列放不下时，再启用它。
* `2` 值，表示无条件开启功能。

**那么在应对 SYN 攻击时，只需要设置为 **`1` 即可：

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n495" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-def">$ echo</span> <span class="cm-number">1</span> > /proc/sys/net/ipv4/tcp_syncookies</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

##### 4）减少 SYN-ACK 重传次数

**当服务端受到 SYN 攻击时，就会有大量处于 **`SYN_REVC` 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN-ACK ，当重传超过次数达到上限后，就会断开连接。

**那么针对 SYN 攻击的场景，我们可以减少 SYN-ACK 的重传次数，以加快处于 **`SYN_REVC` 状态的 TCP 连接断开。

**SYN-ACK 报文的最大重传次数由 **`tcp_synack_retries` 内核参数决定（默认值是 5 次），比如将 `tcp_synack_retries` 减少到 2 次：

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n500" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-def">$ echo</span> <span class="cm-number">2</span> > /proc/sys/net/ipv4/tcp_synack_retries</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

### 四次挥手

![img](./img/0dc25c2e6ae3de02cc4039553165d8cf.png)

**刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：**

* **第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。**

**即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。**

* **第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。**

**即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。**

* **第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。**

**即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。**

* **第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。**

**即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。**

**那为什么需要四次挥手呢？**

**因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。**

**简单来说就是以下四步：**

* **第一次挥手**：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。
* **第二次挥手**：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。
* **第三次挥手**：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。
* **第四次挥手**：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

**TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。**

**最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭**

#### 第一次挥手丢失了，会发生什么？

**当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 **`FIN_WAIT_1` 状态。

**正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 **`FIN_WAIT2` 状态。

**如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发**超时重传**机制，重传 FIN 报文，重发次数由 `tcp_orphan_retries` 参数控制。

**当客户端重传 FIN 报文的次数超过 **`tcp_orphan_retries` 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 `close` 状态。

**举个例子，假设 **`tcp_orphan_retries` 参数值为 3，当第一次挥手一直丢失时，发生的过程如下图：

![第一次挥手丢失](./img/lost-in-first-wave.c639c167.png)

**具体过程：**

* **当客户端超时重传 3 次 FIN 报文后，由于 **`tcp_orphan_retries` 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。

#### 第二次挥手丢失了，会发生什么？

**当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 **`CLOSE_WAIT` 状态。

**在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。**

**举个例子，假设 **`tcp_orphan_retries` 参数值为 2，当第二次挥手一直丢失时，发生的过程如下图：

![第二次挥手丢失](./img/lost-in-second-wave.27229796.png)

**具体过程：**

* **当客户端超时重传 2 次 FIN 报文后，由于 **`tcp_orphan_retries` 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。

**这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 **`FIN_WAIT2` 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。

**对于 close 函数关闭的连接，由于无法再发送和接收数据，所以 **`FIN_WAIT2` 状态不可以持续太久，而 `tcp_fin_timeout` 控制了这个状态下连接的持续时长，默认值是 60 秒。

**这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭，如下图：**

![调用 close 关闭的连接](./img/fin_wait_2-by-close.59fd1ca9.png)

**但是注意，如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。**

**此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 **`FIN_WAIT2` 状态（`tcp_fin_timeout` 无法控制 shutdown 关闭的连接）。如下图：

![调用 shutdown 关闭的连接](./img/fin_wait_2-by-shutdown.f485c6fb.png)

#### 第三次挥手丢失了，会发生什么？

**当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 **`CLOSE_WAIT` 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。

**此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。**

**服务端处于 **`CLOSE_WAIT` 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 `LAST_ACK` 状态，等待客户端返回 ACK 来确认连接关闭。

**如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 **`tcp_orphan_retries` 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。

**举个例子，假设 **`tcp_orphan_retries = 3`，当第三次挥手一直丢失时，发生的过程如下图：

![第三次挥手丢失](./img/lost-in-third-wave.b8f03061.png)

**具体过程：**

* **当服务端重传第三次挥手报文的次数达到了 3 次后，由于 **`tcp_orphan_retries` 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。
* **客户端因为是通过 close 函数关闭连接的，处于 **`FIN_WAIT_2` 状态是有时长限制的，如果 `tcp_fin_timeout` 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。

#### 第四次挥手丢失了，会发生什么？

**当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 **`TIME_WAIT` 状态。

**在 Linux 系统，**`TIME_WAIT` 状态会持续 2MSL 后才会进入关闭状态。

**然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 **`LAST_ACK` 状态。

**如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 **`tcp_orphan_retries` 参数控制。

**举个例子，假设 **`tcp_orphan_retries` 为 2，当第四次挥手一直丢失时，发生的过程如下：

![第四次挥手丢失](./img/lost-in-fourth-wave.80200bab.png)

**具体过程：**

* **当服务端重传第三次挥手报文达到 2 时，由于 **`tcp_orphan_retries` 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。
* **客户端在收到第三次挥手后，就会进入 **`TIME_WAIT` 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。

#### 关于 `TIME_WAIT`

##### 为什么 `TIME_WAIT` 等待的时间是 2MSL？

`MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 `TTL` 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

**MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡。

**TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了**。

`TIME_WAIT` 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**。

**比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。**

**可以看到** **2MSL时长** 这其实是相当于**至少允许报文丢失一次**。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，`TIME_WAIT` 状态的连接可以应对。

**为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。**

`2MSL` 的时间是**从客户端接收到 FIN 后发送 ACK 开始计时的**。如果在 `TIME_WAIT` 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 **2MSL 时间将重新计时**。

**在 Linux 系统里** **`2MSL` 默认是 `60` 秒，那么一个 `MSL` 也就是 `30` 秒。** Linux 系统停留在 `TIME_WAIT` 的时间为固定的 60 秒。

**其定义在 Linux 内核代码里的名称为 **`TCP_TIMEWAIT_LEN`：

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="c" cid="n612" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-meta">#define TCP_TIMEWAIT_LEN (60*HZ) </span><span class="cm-comment">/* how long to wait to destroy TIME-WAIT </span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">                                    <span class="cm-comment">state, about 60 seconds  */</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

**如果要修改 **`TIME_WAIT` 的时间长度，只能修改 Linux 内核代码里 `TCP_TIMEWAIT_LEN` 的值，并重新编译 Linux 内核。

##### 为什么需要 `TIME_WAIT` 状态？

**主动发起关闭连接的一方，才会有 **`TIME_WAIT` 状态。

**需要 **`TIME_WAIT` 状态，主要是两个原因：

* **防止历史连接中的数据，被后面相同四元组的连接错误的接收。**
* **保证「被动关闭连接」的一方，能被正确的关闭。**

##### `TIME_WAIT` 过多有什么危害？

**过多的 **`TIME_WAIT` 状态主要的危害有两种：

* **第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。**
* **第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 **`32768～61000`，也可以通过 `net.ipv4.ip_local_port_range` 参数指定范围。

**客户端和服务端 **`TIME_WAIT` 过多，造成的影响是不同的。

**如果客户端（发起连接方）的 `TIME_WAIT` 状态过多**，占满了所有端口资源，那么就无法对「目的IP + 目的PORT」都一样的服务器发起连接了，但是被使用的端口，还是可以继续对另外一个服务器发起连接的。具体可以看这篇文章：[客户端的端口可以重复使用吗？](https://wenyuan.github.io/basic-skills/network/tcp-wave-exception/#%E8%BF%98%E6%B2%A1%E5%86%99)

**因此，客户端（发起连接方）都是和「目的IP + 目的PORT 」都一样的服务器建立连接的话，当客户端的 **`TIME_WAIT` 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的IP + 目的PORT」都一样的服务器建立连接了。

**不过，即使是在这种场景下，只要连接的是不同的服务器，端口是可以重复使用的，所以客户端还是可以向其他服务器发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。**

**如果服务端（发起连接方）的 `TIME_WAIT` 状态过多**，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。

#### 如何优化 `TIME_WAIT`？

**这里给出优化 **`TIME_WAIT` 的几个方式，都是有利有弊：

* **打开 **`net.ipv4.tcp_tw_reuse` 和 `net.ipv4.tcp_timestamps` 选项。
* `net.ipv4.tcp_max_tw_buckets`
* **程序中使用 **`SO_LINGER`，应用强制使用 `RST` 关闭。

**1）方式一：`net.ipv4.tcp_tw_reuse` 和 `tcp_timestamps`**

**如下的 Linux 内核参数开启后，则可以 **复用处于 `TIME_WAIT` 的 socket 为新的连接所用**。

**有一点需要注意的是，** **`tcp_tw_reuse` 功能只能用客户端（连接发起方），因为开启了该功能，在调用 `connect()` 函数时，内核会随机找一个 `time_wait` 状态超过 `1` 秒的连接给新的连接复用**。

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n646" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">net.ipv4.tcp_tw_reuse <span class="cm-operator">=</span> <span class="cm-number">1</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

**使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n648" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">net.ipv4<span class="cm-def">.tcp_timestamps</span><span class="cm-operator">=</span><span class="cm-number">1</span>（默认即为 <span class="cm-number">1</span>）</span></pre></div></div></div></div></div></div><div></div></div></div></pre>

**这个时间戳的字段是在 TCP 头部的「选项」里，它由一共 8 个字节表示时间戳，其中第一个 4 字节字段用来保存发送该数据包的时间，第二个 4 字节字段用来保存最近一次接收对方发送到达数据的时间。**

**由于引入了时间戳，我们在前面提到的 **`2MSL` 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。

**2）方式二：`net.ipv4.tcp_max_tw_buckets`**

**这个值默认为 18000，** **当系统中处于 `TIME_WAIT` 的连接一旦超过这个值时，系统就会将后面的 `TIME_WAIT` 连接状态重置**，这个方法比较暴力。

**3）方式三：程序中使用 `SO_LINGER`**

**我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="bash" cid="n655" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">struct linger so_linger;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">so_linger.l_onoff <span class="cm-operator">=</span> <span class="cm-number">1</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">so_linger.l_linger <span class="cm-operator">=</span> <span class="cm-number">0</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">setsockopt(s, SOL_SOCKET, SO_LINGER, &so_linger,sizeof(so_linger));</span></pre></div></div></div></div></div><div></div></div></div></pre>

**如果 **`l_onoff` 为非 0， 且 `l_linger` 值为 0，那么调用 `close` 后，会立该发送一个 `RST` 标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了 `TIME_WAIT` 状态，直接关闭。

**但这为跨越 **`TIME_WAIT` 状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。

**前面介绍的方法都是试图越过 **`TIME_WAIT` 状态的，这样其实不太好。虽然 `TIME_WAIT` 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。

**所以更好的方法应该是：**

**如果服务端要避免过多的 `TIME_WAIT` 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 `TIME_WAIT`**。

### TCP 重传机制

#### 超时重传

**重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，如果还没有收到对方的ACK确认应答报文，就会重发该数据，也就是我们常说的超时重传。**

**那么这个指定的时间，应该是多久比较合适呢？**
** 这里先介绍两个概念：**`RTT`和 `RTO`

* `RTT`(Round-Trip Time) 往返时延，指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间
* `RTO`(Retransmission Timeout)，就是超时重传时间。

**通常** `RTO`应该略大于 `RTT`：

* **如果** `RTO`太短，有可能数据没有丢失就重发，增加网络拥塞。
* **如果** `RTO`太长，重发就慢，性能差。

**由于网络的不稳定，**`RTT`是经常变化的，导致 `RTO`也会是一个动态变化的值。

**如果超时重发的数据，再次超时的话，下一次重传的时间间隔则会加倍。**
** 超时重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？**

**TCP用** **快速重传** 机制来解决超时重发的时间等待。

#### 快速重传

**发送方发包的时候，并不总是等待ACK的响应再发送下一个包，而是会在窗口大小内，连续发多个包：**

**如果其中一个包丢失了，而后续的包到达时，接收方会发丢失的包的ACK给发送方。当发送方连接收到三个相同的ACK时，就知道这个包丢失了，于是不用等重传定时，直接就可以重新发送了**

#### SACK

**快速重传机制解决了超时时间的问题，但是它面临着另外一个问题：那就是重传的时候，是重传一个包，还是重传所有的包？像上面的例子，客户端发出19个包，当触发快速重传的时候，客户端只知道第2个包丢失了，那其他包是否丢失，客户端并不清楚，这时候有两种选择：**

* **重发2~19所有的包，显然会造成数据的浪费，因为后面17个包都是已经收到的。**
* **只重发第2个包。但如果第3个包也丢失的话，那么又得等到三次ACK才能重发第3个包，效率较低。**

**这时候，** **`SACK(Selective Acknowledgment)`，选择性确认，就可以起作用了。**
**这种方式需要在TCP头部** **选项** 字段里加一个 `SACK`的选项，它可以将已收到的数据的信息发送给发送方 ，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据了 。

**在这个例子中，**`SACK`表示 `15870601~15873581`之间的数据是已经收到的，所以客户端只需要重发 `15869201~15870600`之间的数据就行了。

**由于TCP头部大小的限制，在选项中最多能支持四组SACK的数据**

### TCP的拥塞控制机制

**TCP的拥塞控制机制主要是以下四种机制：**

* **慢启动（慢开始）**
* **拥塞避免**
* **快速重传**
* **快速恢复**

**（1）慢启动（慢开始）**

* **在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）**
* **思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。**
* **为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)**
* * **当cnwd < ssthresh，使用慢开始算法**
  * **当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法**
  * **当cnwd > ssthresh，使用拥塞避免算法**

**（2）拥塞避免**

* **拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。**
* **思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一**
* **无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:**
  ![img](./img/20200802172257514.png)
  **其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。**

**（3）快速重传**

* **快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。**
* **由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量**

**（4）快速恢复**

* **当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。**
* **考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。**
  ![img](./img/2020080217284188.png)

### TCP的流量控制机制

**一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的 **滑动窗口** 进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。

* **当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。**
* **当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）**
* **如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。**
* **如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。**

# HTTP

**HTTP 是** **超文本传输协议**，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 **80 端口**。它使用 **TCP** 作为传输层协议，保证了数据传输的可靠性。

**HTTP协议具有以下** **优点**：

* **支持** **客户端/服务器** 模式
* **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
* **无连接**：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
* **无状态**：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。
* **灵活**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

**HTTP协议具有以下** **缺点**：

* **无状态：**HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。
* **明文传输：**协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
* **不安全**

**（1）通信使用明文（不加密），内容可能会被窃听；**

**（2）不验证通信方的身份，因此有可能遭遇伪装；**

**（3）无法证明报文的完整性，所以有可能已遭篡改；**

## 请求报文

**请求报⽂有4部分组成: **

* **请求⾏ ：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 **
* **请求头部 **
* **请求头部：**
  **由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔  **
  * **User-Agent：产⽣请求的浏览器类型。 **
  * **Accept：客户端可识别的内容类型列表。 **
  * **Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机**
* **空⾏**
* **请求体 ：post put等请求携带的数据**

**请求方法：**

| **请求方法**   | **get**                                  | **post**                                     | **put**            |
| -------------------- | ---------------------------------------------- | -------------------------------------------------- | ------------------------ |
| **幂等**       | **Get 请求用于对服务器资源不会产生影响** | **更新服务器资源**                           | **创建服务器资源** |
| **缓存**       | **请求缓存**                             | **默认不缓存**                               | **默认不缓存**     |
| **数据位置**   | **URL**                                  | **请求体body**                               | **请求体body**     |
| **浏览器刷新** | **回车/刷新无害**                        | **重复提交会触发警告（需确认是否重新发送）** |                          |

**options方法**

**OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。**

**OPTIONS方法是用于请求获得由** `Request-URI`标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以**在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能**。该请求方法的响应不能缓存。

**OPTIONS请求方法的** **主要用途** 有两个：

* **获取服务器支持的所有HTTP请求方法；**
* **用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限**

**简单请求 (Simple Request)**

**一个请求必须** **同时满足以下所有条件**，才是简单请求：

1. **HTTP 方法限制为以下三种之一：**
   * `GET`
   * `HEAD`
   * `POST`
2. **HTTP 头部限制 (由浏览器自动设置的头除外)：** 只能包含以下**安全列表**中的请求头字段：
   * `Accept`
   * `Accept-Language`
   * `Content-Language`
   * `Content-Type` (但值有额外限制，见下一点)
   * `DPR`
   * `Downlink`
   * `Save-Data`
   * `Viewport-Width`
   * `Width`
   * **... (这个列表相对固定，主要是浏览器自动设置或非常基础的头部)**
3. **`Content-Type` 头的值限制为以下三种之一：**
   * `application/x-www-form-urlencoded`
   * `multipart/form-data`
   * `text/plain`

**简单请求的特点：**

* **浏览器会** **直接发送** 实际请求（GET/POST等）。
* **在请求中自动添加 **`Origin` 头，表明来源。
* **服务器需要在响应中包含至少 **`Access-Control-Allow-Origin` 头（值可以是 `*` 或具体的请求来源域）来允许跨域。如果涉及凭据（如 Cookies），还需要 `Access-Control-Allow-Credentials: true`。
* **常见例子：**
  * **使用原生 HTML **`<form>` 提交的 POST 请求（`enctype` 为上述三种之一）。
  * **使用原生 **`XMLHttpRequest` 或 `fetch` 发起的 GET 请求（不带自定义头，`Content-Type` 为上述三种之一）。
  * **使用 **`fetch` 发起的 POST 请求，请求体是 `FormData` 或 URL 编码字符串，且没有设置自定义头。

**非简单请求 (Preflighted Request / 预检请求)**

**如果一个请求** **不满足** 上述简单请求的**任何一个条件**，它就是**非简单请求**（预检请求）。

**触发非简单请求的常见情况：**

1. **使用了 `GET`, `HEAD`, `POST` 之外的 HTTP 方法：**
   * `PUT`
   * `DELETE`
   * `PATCH`
   * `CONNECT`
   * `OPTIONS` (虽然 OPTIONS 本身用于预检，但其他方法触发预检时用 OPTIONS)
   * `TRACE`
   * **或者任何自定义方法（如 `PURGE`）**
2. **设置了不在“安全列表”中的请求头：**
   * **任何** **自定义请求头**（如 `X-Auth-Token`, `X-Requested-With`）。
   * **一些不在安全列表中的标准头（如 **`Authorization`, `Content-Type` 的值超出简单请求范围）。
3. **`Content-Type` 的值不是简单请求允许的三种：**
   * **最常见的就是 **`application/json`。
   * `application/xml` 或 `text/xml` 等。
   * **任何其他非 **`text/plain`, `application/x-www-form-urlencoded`, `multipart/form-data` 的值。

**非简单请求的特点：**

* **浏览器会先自动发送一个 `OPTIONS` 方法的“预检请求”** 到目标服务器。
* **预检请求携带关键头信息询问服务器：**
  * `Origin`: 请求来源。
  * `Access-Control-Request-Method`: 后续实际请求想要使用的 HTTP 方法（如 PUT, DELETE）。
  * `Access-Control-Request-Headers`: 后续实际请求想要携带的自定义请求头列表（如 `Content-Type`, `Authorization`）。
* **服务器必须响应预检请求 (`OPTIONS`)：**
  * **返回状态码通常是 **`204 No Content` 或 `200 OK`。
  * **必须包含关键的 CORS 响应头：**
    * `Access-Control-Allow-Origin`: 允许的来源（`*` 或具体域）。
    * `Access-Control-Allow-Methods`: 允许的实际请求方法（如 `PUT, DELETE`）。
    * `Access-Control-Allow-Headers`: 允许的实际请求头（如 `Content-Type, Authorization`）。
    * **(可选) **`Access-Control-Allow-Credentials: true`（如需凭据）。
    * **(可选) **`Access-Control-Max-Age`: 预检结果缓存时间（秒）。
* **浏览器决策：**
  * **如果预检响应头**符合**后续实际请求的要求（方法、头、来源都被允许），浏览器才会**接着发送真正的实际请求**（PUT, DELETE, 带 JSON 的 POST 等）。
  * **如果预检响应头**拒绝**了实际请求（比如没包含某个方法或头），浏览器会**阻止**后续实际请求的发送，并在控制台报 CORS 错误。
* **常见例子：**
  * **发送 **`application/json` 数据的 POST/PUT 请求。
  * **发送 DELETE 请求。**
  * **在请求头中添加 **`Authorization: Bearer <token>` 进行认证。
  * **发送任何自定义 HTTP 方法的请求。**
  * **使用自定义头如 **`X-Custom-Header`。

## 响应报文

**请求报⽂有4部分组成: **

* **响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。 **
* **响应头：响应部⾸组成 **
* **空行**
* **响应体：服务器响应的数据**

## HTTP 版本演进对比

| **特性**         | **HTTP/0.9 (1991)**          | **HTTP/1.0 (1996)**                                      | **HTTP/1.1 (1997/1999)**                                                | **HTTP/2 (2015)**                                   | **HTTP/3 (2022)**                         |
| ---------------------- | ---------------------------------- | -------------------------------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------- | ----------------------------------------------- |
| **协议基础**     | **单行文本协议**             | **文本协议 + 头部**                                      | **文本协议（增强版）**                                                  | **二进制分帧协议**                                  | **基于 QUIC 的 UDP 协议**                 |
| **连接方式**     | **⚡ 单请求后立即关闭**      | **⚡ 默认短连接（可手动设** `Connection: keep-alive`） | **✅**默认长连接**（持久化）                                          | **✅ 多路复用单连接**                               | **✅ 多路复用 +**连接迁移**             |
| **并行请求**     | **❌ 不支持**                | **❌ 不支持（串行）**                                    | **🟡 有限并行（6-8个/域名，需域名分片）**                               | **✅**真并行**（单连接多流）                      | **✅**零队头阻塞**（流独立）            |
| **头部传输**     | **❌ 无头部**                | **✅ 文本头部（未压缩）**                                | **✅ 文本头部（未压缩）**                                               | **✅**HPACK 压缩**（二进制）                      | **✅**QPACK 压缩**（动态表）            |
| **数据传输**     | **❌ 仅文本（无类型/长度）** | **✅ 支持二进制（**`Content-Type`）                    | **✅ 支持分块传输（**`Transfer-Encoding: chunked`）                   | **✅ 二进制帧（**`DATA`帧）                       | **✅ 二进制帧（**`STREAM`帧）           |
| **关键性能优化** | **-**                        | **-**                                                    | **🔹 管道化（易队头阻塞） 🔹 缓存控制（**`Cache-Control`）            | **🔹**多路复用**🔹 服务器推送（`PUSH_PROMISE`） | **🔹**0-RTT 快速握手**🔹 改进的丢包恢复 |
| **队头阻塞问题** | **❌ 无（单请求）**          | **❌ 无（串行）**                                        | **🔴**存在**（响应必须顺序返回）                                      | **🔴**TCP 层队头阻塞**                            | **✅**彻底解决**（QUIC 流隔离）         |
| **安全性**       | **❌ 无加密**                | **❌ 无强制加密**                                        | **❌ 无强制加密**                                                       | **⚠️ 事实需 HTTPS（浏览器强制）**                 | **✅**内置 TLS 1.3**                    |
| **握手延迟**     | **1× RTT（TCP）**           | **1× RTT（TCP）**                                       | **1× RTT（TCP）**                                                      | **1~3× RTT（TCP+TLS）**                            | **✅**0~1× RTT**（QUIC 0-RTT）         |
| **典型请求示例** | `GET /page`                      | `<br>GET /page HTTP/1.0<br>Host: example.com<br>`            | `<br>GET /page HTTP/1.1<br>Host: example.com<br>Connection: keep-alive<br>` | **二进制帧（含流ID、头部块等）**                    | **QUIC 数据包（含连接ID、流ID）**         |
| **核心缺陷**     | **功能极简**                 | **连接开销大**                                           | **队头阻塞 + 头部冗余**                                                 | **TCP 队头阻塞**                                    | **部署复杂度高**                          |

---

### 关键特性详解

#### 1. **HTTP/1.1 核心改进**

* **持久连接**：复用 TCP 连接（省去重复握手开销）。
* **管道化（Pipelining）**：允许连续发送多个请求（但响应必须按序返回 → **队头阻塞**）。
* **分块传输**：支持流式大数据传输（`Transfer-Encoding: chunked`）。
* **缓存控制**：`Cache-Control`、`ETag` 等精细化缓存策略。

#### 2. **HTTP/2 革命性突破**

* **二进制分帧层**：
  * **将消息拆分为 **HEADERS 帧**和 **DATA 帧**，通过**流标识符（Stream ID）** 重组。
* **多路复用（Multiplexing）**：
  * **单 TCP 连接上并行传输多个流，解决 HTTP/1.1 并发限制。**
* **头部压缩（HPACK）**：
  * **静态霍夫曼编码 + 动态表减少头部冗余（尤其 Cookie）。**
* **服务器推送（Server Push）**：
  * **主动推送关联资源（如 CSS/JS）减少客户端请求。**

#### 3. **HTTP/3 的底层革新**

* **QUIC 协议取代 TCP**：
  * **基于 UDP 实现可靠传输，内置加密（TLS 1.3）和拥塞控制。**
* **连接迁移**：
  * **切换网络时（WiFi→4G）**连接 ID 不变**，无需重新握手。
* **零 RTT 建连**：
  * **首次访问 1-RTT，后续访问 0-RTT（类似 TLS 会话恢复）。**
* **彻底解决队头阻塞**：
  * **QUIC 的流（Stream）独立传输，丢包只影响当前**

**HTTP/3 基于 UDP 实现可靠传输的核心技术是 **QUIC 协议**（Quick UDP Internet Connections）。QUIC 在 UDP 之上重建了可靠性机制，同时融合了 TCP 和 TLS 的优点。以下是其实现可靠传输的关键技术：

---

### 一、QUIC 的核心可靠性机制

#### 1. **数据包编号机制**

* **单调递增的 Packet Number**：
  * **每个数据包都有唯一递增编号（不同于 TCP 序列号）**
  * **解决 TCP 重传歧义问题（重传包使用新编号）**
* **示例**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1159" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">初始发送：Packet #1, #2, #3</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">丢包重传：重传的包变为 Packet #4（而非复用旧编号）</span></pre></div></div></div></div></div><div></div></div></div></pre>

#### 2. **改进的确认机制**

* **ACK 帧带延迟信息**：
  * **携带精确的接收时间戳（用于 RTT 计算）**
  * **支持**选择性确认（SACK）**，明确告知丢失范围
* **显式丢包通知**：
  * **通过 NACK（Negative ACK）快速报告丢包**

#### 3. **前向纠错（FEC）**

* **发送冗余的 FEC 包（异或校验包）**
* **丢失单个包时可通过其他包+FEC包重建数据**
* **减少小规模丢包时的重传**

---

### 二、连接管理机制

#### 1. **连接迁移**

* **Connection ID 标识连接**
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1188" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">// 连接标识（IP变化时仍有效）</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">connection_id = 0x8a4f3b2c</span></pre></div></div></div></div></div><div></div></div></div></pre>
* **当客户端 IP 改变（如 WiFi 切 4G），TCP 需重建连接，QUIC 保持连接**

#### 2. **0-RTT 快速重启**

* **基于 TLS 1.3 的会话恢复**
* **之前连接过的客户端可在首次包中携带数据**

---

### 三、多路复用与流控制

#### 1. **流（Stream）隔离**

* **单个 QUIC 连接支持多个独立 Stream**
* **关键优势**：一个 Stream 丢包不影响其他 Stream（解决 TCP 队头阻塞）

#### 2. **分级流量控制**

* **两层控制：**
  1. **连接级控制**（总带宽限制）
  2. **流级控制**（每个流的独立窗口）
* **动态窗口调整算法**
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1216" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">// 伪代码：窗口增长逻辑</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">if (no_loss_event) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    window_size *= 1.5; // 指数增长</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">} else {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    window_size *= 0.7; // 乘性减少</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">}</span></pre></div></div></div></div></div><div></div></div></div></pre>

---

### 四、安全与拥塞控制

#### 1. **深度集成加密**

* **头部加密**：连包类型都加密（防中间设备干扰）
* **认证加密**：使用 AES-GCM/ChaCha20-Poly1305
* **密钥轮换**：每个包使用不同密钥

#### 2. **智能拥塞控制**

* **可插拔算法**：
  * **默认使用 **Cubic**（类似 TCP）
  * **可选 **BBR**（Google 的 Bottleneck Bandwidth and RTT）
* **带宽预测模型**：**
  **BDP=Bmax×RTTmin*B**D**P*=*B**ma**x*×*RT**T**min***
  **（BDP：带宽延迟积，决定最优窗口大小）

---

### 五、QUIC vs TCP 可靠性对比

| **特性**     | **TCP**              | **QUIC over UDP**       |
| ------------------ | -------------------------- | ----------------------------- |
| **握手延迟** | **3-RTT（TCP+TLS）** | **1-RTT（0-RTT 可选）** |
| **队头阻塞** | **有（单流阻塞）**   | **无（多流隔离）**      |
| **重传歧义** | **有（相同序列号）** | **无（唯一递增包号）**  |
| **连接迁移** | **不支持**           | **原生支持**            |
| **前向纠错** | **无**               | **可选支持**            |
| **加密范围** | **仅加密负载**       | **加密头部+负载**       |

---

### 六、典型数据传输流程

**以文件下载为例：**

1. **连接建立**
   <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1275" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Client → Server: Client Hello (携带 0-RTT 数据)</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Server → Client: Server Hello + ACK</span></pre></div></div></div></div></div><div></div></div></div></pre>
2. **数据传输**：
   <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1278" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Client: 发送 Stream1 数据包#1-#10</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Server: 收到 #1,#3-#10 → 回复 ACK(范围) + NACK(#2)</span></pre></div></div></div></div></div><div></div></div></div></pre>
3. **丢包恢复**：
   * **选项1：快速重传（收到3个重复ACK后立即重传#2）**
   * **选项2：FEC重建（若配置了前向纠错）**
4. **拥塞响应**：
   * **检测到丢包 → 窗口减半**
   * **持续无丢包 → 窗口指数增长**

---

### 七、技术挑战与解决方案

| **挑战**              | **QUIC 解决方案**                |
| --------------------------- | -------------------------------------- |
| **UDP 不可靠**        | **自定义ACK/NACK+重传**          |
| **NAT 防火墙阻挡UDP** | **回落TCP（HTTP/2备用）**        |
| **中间设备干扰UDP**   | **加密所有头部信息**             |
| **操作系统内核限制**  | **用户空间实现（无需内核升级）** |
| **移动网络切换断连**  | **Connection ID 保持连接**       |

---

### 总结

**HTTP/3 通过 QUIC 在 UDP 上实现可靠传输的关键是：**

1. **重建可靠性基础**：包编号、ACK/NACK、重传
2. **创新设计**：流隔离、连接迁移、0-RTT
3. **深度安全集成**：全加密、密钥轮换
4. **灵活拥塞控制**：可插拔算法、带宽预测

**这使得 QUIC 在保留 UDP 高效性的同时，获得了比 TCP 更优的可靠性和性能，尤其在高丢包、移动网络环境下表现显著提升。**

# HTTPS

**HTTPS = HTTP + TLS/SSL，通过**加密传输**和**身份认证**保障安全。以下是完整连接过程（以 TLS 1.3 简化流程为例）：

---

### **HTTPS 连接建立流程**

#### **阶段 1：TCP 三次握手**（基础连接）

1. **客户端 → 服务器：**`SYN`
2. **服务器 → 客户端：**`SYN + ACK`
3. **客户端 → 服务器：**`ACK`
   **✅ **此时建立 TCP 连接（未加密）**

---

#### **阶段 2：TLS 握手**（核心安全层）

##### **步骤 1：Client Hello**

* **客户端发送：**
  * **支持的 TLS 版本**
  * **客户端随机数（Client Random）**
  * **支持的加密套件列表（如 **`TLS_AES_128_GCM_SHA256`）

##### **步骤 2：Server Hello**

* **服务器响应：**
  * **选定的 TLS 版本**
  * **服务器随机数（Server Random）**
  * **选定的加密套件**
  * **服务器证书链**（含公钥、域名、CA 签名）

##### **步骤 3：证书验证**（关键安全步骤）

1. **客户端验证证书：**
   * **检查域名是否匹配**
   * **检查有效期**
   * **验证 CA 签名链**（详见下方 CA 验证机制）
   * **查询 OCSP 或 CRL 确认未吊销**

##### **步骤 4：密钥交换**

* **非对称加密阶段**（仅此阶段使用）：
  * **客户端生成 **Pre-Master Secret**
  * **用**服务器证书公钥**加密后发送 → 服务器
* **服务器用**私钥解密**获取 Pre-Master Secret

##### **步骤 5：生成会话密钥**

* **双方通过以下参数生成**对称会话密钥**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1393" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Master Secret = PRF(Client Random + Server Random + Pre-Master Secret)  </span></pre></div></div></div></div></div></div><div></div></div></div></pre>
* **✅ **会话密钥用于后续对称加密**

##### **步骤 6：完成握手**

* **双方发送 **`Finished` 消息（用会话密钥加密）
* **验证握手完整性**

---

#### **阶段 3：加密数据传输**

* **对称加密阶段**（高效加密）：
  * **所有 HTTP 数据被拆分为 **TLS Record**
  * **使用会话密钥进行 AES/GCM 加密传输**
  * **示例：**
    <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1414" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">[加密后] 2F 8A 01 9C... → 传输 → 服务器解密为 "GET /index.html HTTP/1.1"  </span></pre></div></div></div></div></div></div><div></div></div></div></pre>

---

### CA 证书验证机制

**证书验证是防范中间人攻击的核心：**

1. **证书链校验**：
   * **服务器证书 → 中间 CA 证书 → 根 CA 证书**
   * **客户端用**本地信任的根 CA 公钥**验证签名链
2. **吊销检查**：
   * **OCSP（在线证书状态协议）**：实时查询证书状态
   * **CRL（证书吊销列表）**：定期下载黑名单
3. **扩展验证**：
   * **EV 证书验证组织真实性（显示绿色企业名称）**

---

### 无响应时的处理策略

**TLS 协议内置超时重传机制：**

| **场景**                | **处理方式**                                    | **超时时间**            |
| ----------------------------- | ----------------------------------------------------- | ----------------------------- |
| **Client Hello 无响应** | **客户端重发（指数退避算法）**                  | **初始 1s → 最大 60s** |
| **握手中途失败**        | **关闭连接并触发** `TLS Handshake Failed`错误 | **TCP 层决定**          |
| **应用数据传输超时**    | **TCP 重传机制触发**                            | **动态 RTO 计算**       |

---

### 防范中间人攻击（MitM）措施

**HTTPS 通过四重机制防御：**

1. **证书签名体系**：
   * **攻击者无法伪造 CA 签名的合法证书（除非控制根 CA）**
2. **公钥绑定**：
   * **浏览器强制检查证书域名（HSTS 可阻止降级攻击）**
3. **密钥交换保密**：
   * **Pre-Master Secret 用**服务器公钥加密**，仅私钥持有者可解密
4. **双向认证（可选）**：
   * **服务器要求客户端提供证书（用于银行等高安全场景）**

**经典 MitM 攻击失败原因**：**
**攻击者截获流量时：

* **若提供**自签名证书** → 浏览器显示 `NET::ERR_CERT_AUTHORITY_INVALID`
* **若提供**盗用证书** → 私钥不在攻击者手中，无法解密 Pre-Master Secret

---

### 加密技术总结

| **阶段**         | **加密类型**   | **算法示例**                 | **作用**                       |
| ---------------------- | -------------------- | ---------------------------------- | ------------------------------------ |
| **证书公钥传输** | **非对称加密** | **RSA 2048 / ECC secp256r1** | **安全传递 Pre-Master Secret** |
| **会话密钥生成** | **密钥协商**   | **ECDHE / DHE**              | **前向保密保障**               |
| **应用数据传输** | **对称加密**   | **AES-128-GCM / ChaCha20**   | **高效加密实际内容**           |

---

### 核心安全设计思想

1. **非对称加密建立信任** → 解决密钥分发问题
2. **对称加密高效通信** → 解决性能瓶颈
3. **PKI 体系验证身份** → 防范中间人攻击
4. **前向保密（PFS）** → 即使私钥泄露，历史会话仍安全

**通过以上机制，HTTPS 在开放网络中构建了机密性、完整性和身份认证三大安全支柱。**

## 与浏览器相关

### **1. 渲染进程（Renderer Process） - 请求发起**

* **触发位置**：Blink渲染引擎（如V8执行JavaScript）
* **关键操作**：
  * **解析HTML中的** `<a>`、`<img>`等资源标签
  * **执行JavaScript中的** `fetch()`或 `XMLHttpRequest`
  * **生成**HTTP请求头**（包含URL、Method、Cookie等）
* **协议栈入口**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="js" cid="n1542" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 示例：JS发起请求</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">fetch</span>(<span class="cm-string">'https://api.example.com/data'</span>, {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-property">method</span>: <span class="cm-string">'POST'</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-property">headers</span>: {<span class="cm-string cm-property">'Content-Type'</span>: <span class="cm-string">'application/json'</span>},</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-property">body</span>: <span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>({<span class="cm-property">key</span>: <span class="cm-string">'value'</span>})</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">});</span></pre></div></div></div></div></div><div></div></div></div></pre>
* **跨进程通信**：通过**Mojo IPC**将请求发送给网络进程

### **2. 网络进程（Network Service） - 协议栈核心**

* **核心组件**：
  * **HTTP/HTTP2栈**：处理应用层协议
  * **QUIC实现**：基于UDP的HTTP/3
  * **TLS/SSL引擎**：加密解密
  * **TCP/UDP套接字管理**
* **协议处理流程**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1560" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">┌─────────────────────┐</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 接收渲染进程请求     │</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 1. 检查缓存         │ → MemoryCache/DiskCache</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 2. 解析URL          │ → 提取协议/主机/端口</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 3. 处理HTTP语义     │ → 添加Cookie/UA/Referer</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 4. TLS握手协商      │ → RSA/ECDHE密钥交换</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 5. TCP连接管理      │ → 复用连接或三次握手</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 6. 数据分帧发送      │ → HTTP/2二进制分帧</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 7. 接收响应         │ → 处理重定向/压缩</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">├─────────────────────┤</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">│ 8. 流式传输给渲染进程│ ← 通过IPC管道</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">└─────────────────────┘</span></pre></div></div></div></div></div><div></div></div></div></pre>

### **3. 浏览器进程（Browser Process） - 全局管控**

* **关键职责**：
  * **Cookie管理**：通过CookieStore访问存储
  * **证书验证**：调用系统证书库
  * **代理配置**：应用PAC脚本或系统代理
  * **安全策略**：CORS预检、HSTS强制HTTPS
  * **网络隔离**：实施Site Isolation策略
* **跨域处理示例**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="" cid="n1578" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">渲染进程 → 请求api.other.com</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">网络进程 → 触发CORS预检OPTIONS请求</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">浏览器进程 → 验证跨域策略</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">网络进程 → 转发实际请求</span></pre></div></div></div></div></div><div></div></div></div></pre>

### **4. 操作系统内核 - 底层协议执行**

* **TCP/IP栈**：内核处理三次握手、拥塞控制
* **套接字操作**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="c" cid="n1585" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 伪代码：网络进程调用系统API</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable-3">int</span> <span class="cm-variable">sockfd</span> <span class="cm-operator">=</span> <span class="cm-variable">socket</span>(<span class="cm-variable">AF_INET</span>, <span class="cm-variable">SOCK_STREAM</span>, <span class="cm-number">0</span>); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">connect</span>(<span class="cm-variable">sockfd</span>, (<span class="cm-keyword">struct</span> <span class="cm-def">sockaddr</span><span class="cm-operator">*</span>)<span class="cm-operator">&</span><span class="cm-variable">serv_addr</span>, <span class="cm-keyword">sizeof</span>(<span class="cm-variable">serv_addr</span>));</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">write</span>(<span class="cm-variable">sockfd</span>, <span class="cm-variable">http_request</span>, <span class="cm-variable">strlen</span>(<span class="cm-variable">http_request</span>));</span></pre></div></div></div></div></div><div></div></div></div></pre>

# 浏览器

## 进程与线程

**从本质上说，进程和线程都是 CPU 工作时间片的一个描述：**

* **进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。**
* **线程是进程中的更小单位，描述了执行一段指令所需的时间。**

**进程是资源分配的最小单位，线程是CPU调度的最小单位。**

**进程和线程的区别**

* **进程可以看做独立应用，线程不能**
* **资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。**
* **通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。**
* **调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。**
* **系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小**

**一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。

**进程是运行在虚拟内存上的**，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。

**如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存**。

**进程和线程之间的关系有以下四个特点：**

**（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。**

**（2）线程之间共享进程中的数据。**

**（3）当一个进程关闭之后，操作系统会回收进程所占用的内存**。当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。

**（4）进程之间的内容相互隔离**进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。

### 死锁

**所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。**

**系统中的资源可以分为两类：**

* **可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；**
* **不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。**

**产生死锁的原因：**

**（1）竞争资源**

* **产生死锁中的竞争资源之一指的是**竞争不可剥夺资源**（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
* **产生死锁中的竞争资源另外一种资源指的是**竞争临时资源**（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁

**（2）进程间推进顺序非法**

**若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁**

**产生死锁的必要条件：**

* **互斥条件**：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
* **请求和保持条件**：当进程因请求资源而阻塞时，对已获得的资源保持不放。
* **不剥夺条件**：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
* **环路等待条件**：在发生死锁时，必然存在一个进程——资源的环形链。

**预防死锁的方法：**

* **资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）**
* **只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）**
* **可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）**
* **资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）**

**孤儿进程**：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

**僵尸进程**：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程

### 进程之间的通信方式

**（1）管道通信**

**管道是一种最基本的进程间通信机制。**管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。**

**管道的特点：**

* **只能单向通信**
* **只能血缘关系的进程进行通信**
* **依赖于文件系统**
* **生命周期随进程**
* **面向字节流的服务**
* **管道内部提供了同步机制**

**（2）消息队列通信**

**消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。**

**使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。**

**（3）信号量通信**

**共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。**

**（4）信号通信**

**信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。**

**（5）共享内存通信**

**共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。**

**（6）套接字通信**

**上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。**

## **Chrome浏览器的架构图**：

![img](./img/21994.jpg)

**从图中可以看出，最新的 Chrome 浏览器包括：**

* **1 个浏览器主进程**
* **1 个 GPU 进程**
* **1 个网络进程**
* **多个渲染进程**
* **多个插件进程**

**这些进程的功能：**

* **浏览器进程**：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
* **渲染进程**：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
* **GPU 进程**：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
* **网络进程**：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
* **插件进程**：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

**所以，**打开一个网页，最少需要四个进程**：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

**虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：**

* **更高的资源占用**：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
* **更复杂的体系架构**：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

### 浏览器渲染进程的线程有哪些

**浏览器的渲染进程的线程总共有五种：**

![img](./img/19964.jpg)

**（1）GUI渲染线程**

**负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要**重绘**或由于某种操作引发**回流**时，该线程就会执行。

**浏览器渲染主要有以下步骤：**

* **首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。**
* **然后对 CSS 进行解析，生成 CSSOM 规则树。**
* **根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。**
* **当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。**
* **布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。**

**大致过程如图所示：**

![img](./img/1810.jpg)

**注意**：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

**注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。**

#### 浏览器渲染优化

**  （1）针对JavaScript：JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：**

1. **尽量将JavaScript文件放在body的最后**
2. **body中间尽量不要写﻿script标签**
3. **script标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：**
   **● script 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；**
   **● async 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序**
   **● defer 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。**

** （2）针对CSS：使用CSS有三种方式：使用link、@import、内联样式，**

**其中link和@import都是导入外部样式。它们之间的区别：**

* **link：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码**
* **@import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)**
* **style：GUI直接渲染**

** 外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。**

** 所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。**

** （3）针对DOM树、CSSOM树：**
** 可以通过以下几种方式来减少渲染的时间：**
** ● HTML文件的代码层级尽量不要太深**
** ● 使用语义化的标签，来避免不标准语义化的特殊处理**
** ● 减少CSS代码的层级，因为选择器是从左向右进行解析的**

** （4）减少回流与重绘：**
** ● 操作DOM时，尽量在低层级的DOM节点进行操作**
** ● 不要使用﻿table﻿布局， 一个小的改动可能会使整个﻿table﻿进行重新布局**
** ● 使用CSS的表达式**
** ● 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。**
** ● 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素**
** ● 避免频繁操作DOM，可以创建一个文档片段﻿documentFragment﻿，在它上面应用所有DOM操作，最后再把它添加到文档中**
** ● 将元素先设置﻿display: none﻿，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。**
** ● 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。**

** 浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列**

** 浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**

** 将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。**

#### 渲染过程中遇到 JS 文件如何处理？

**JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。**

#### 什么是文档的预解析？

**Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。**

#### **CSS 如何阻塞文档解析？**

**理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。**

#### 如何优化关键渲染路径？

**  为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：**
**  （1）关键资源的数量。**
**  （2）关键路径长度。**
**  （3）关键字节的数量。**

** 关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。**

** 优化关键渲染路径的常规步骤如下：**
**  （1）对关键路径进行分析和特性描述：资源数、字节数、长度。**
**  （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。**
**  （3）优化关键字节数以缩短下载时间（往返次数）。**
**  （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度**

#### 什么情况会阻塞渲染？

**首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。**

**当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。**

**（2）JS引擎线程**

**JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；**

![](./img/deepseek_mermaid_20250628_8a7e0d.png)

#### 详细步骤说明（以V8引擎为例）

1. **解析（Parsing）阶段**

* **词法分析（Lexical Analysis）**：
  * **将源代码分解为**令牌（Tokens）**
  * **示例：**`const sum = (a, b) => a + b;` →**
    **`[const, sum, =, (, a, ,, b, ), =>, a, +, b, ;]`
* **语法分析（Syntax Analysis）**：
  * **根据ECMAScript规范构建**抽象语法树（AST）**
  * **工具：Esprima、Acorn**
  * **示例AST结构：**
    <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="json" cid="n1829" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="json"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">{</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-string cm-property">"type"</span>: <span class="cm-string">"Program"</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-string cm-property">"body"</span>: [{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-string cm-property">"type"</span>: <span class="cm-string">"VariableDeclaration"</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-string cm-property">"declarations"</span>: [{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">      <span class="cm-string cm-property">"type"</span>: <span class="cm-string">"VariableDeclarator"</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">      <span class="cm-string cm-property">"id"</span>: { <span class="cm-string cm-property">"type"</span>: <span class="cm-string">"Identifier"</span>, <span class="cm-string cm-property">"name"</span>: <span class="cm-string">"sum"</span> },</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">      <span class="cm-string cm-property">"init"</span>: {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">        <span class="cm-string cm-property">"type"</span>: <span class="cm-string">"ArrowFunctionExpression"</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">        <span class="cm-string cm-property">"params"</span>: [<span class="cm-meta">...</span>],</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">        <span class="cm-string">"body"</span>: { <span class="cm-meta">...</span> }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">      }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    }]</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  }]</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">}</span></pre></div></div></div></div></div><div></div></div></div></pre>

2. **预编译阶段**

* **关键处理**：
  * **函数声明和变量提升**
  * **创建词法环境（Lexical Environment）**
  * **建立作用域链（Scope Chain）**
  * **闭包预处理**

3. **编译阶段**

**a) **解释器路径（Ignition）**

* **将AST转换为**字节码（Bytecode）**
* **字节码示例：**
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="text" cid="n1854" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="text"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">LdaNamedProperty a0, [0]</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Add a1, [1]</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">Return</span></pre></div></div></div></div></div><div></div></div></div></pre>
* **优点：快速启动，跨平台**

**b) **优化编译器路径（TurboFan）**

* **监控热点函数（多次执行的代码）**
* **生成高度优化的**机器码**
* **优化技术：**
  * **内联缓存（Inline Caches）**
  * **隐藏类（Hidden Classes）**
  * **类型反馈（Type Feedback）**

4. **执行阶段**

* **执行上下文（Execution Context）**：
  * **包含：**
    * **变量环境（VariableEnvironment）**
    * **词法环境（LexicalEnvironment）**
    * **this绑定**
* **调用栈管理**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="js" cid="n1890" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><span><span></span></span></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">function</span> <span class="cm-def">first</span>() { <span class="cm-variable">second</span>(); }</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">function</span> <span class="cm-def">second</span>() { <span class="cm-variable">third</span>(); }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">function</span> <span class="cm-def">third</span>() { <span class="cm-variable">console</span>.<span class="cm-property">trace</span>(); }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">first</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 调用栈：</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// third</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// second</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// first</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// (anonymous)</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

5. **优化与反优化**

* **优化条件**：
  * **函数被多次调用（通常 > 10次）**
  * **参数类型稳定**
* **反优化场景**：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="js" cid="n1904" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">function</span> <span class="cm-def">add</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>; }</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 优化路径（数字）</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">add</span>(<span class="cm-number">1</span>, <span class="cm-number">2</span>); <span class="cm-comment">// 类型：Number</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">add</span>(<span class="cm-number">3</span>, <span class="cm-number">4</span>); <span class="cm-comment">// 仍为Number → 保持优化</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 反优化路径</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">add</span>(<span class="cm-string">"5"</span>, <span class="cm-string">"6"</span>); <span class="cm-comment">// 类型变为String → 丢弃机器码</span></span></pre></div></div></div></div></div><div></div></div></div></pre>

6. **内存管理**

* **垃圾回收策略**：
  * **新生代（New Space）**：Scavenge算法（复制）
  * **老生代（Old Space）**：标记-清除（Mark-Sweep） + 标记-整理（Mark-Compact）
* **回收时机**：
  * **内存分配失败时**
  * **定时执行（增量标记）**

**注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。**

**（3）事件触发线程**

**事件触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；**

![](./img/deepseek_mermaid_20250628_9843a9.png)

**注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；**

**（4）定时器触发进程**

**定时器触发进程**即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；

**注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。**

**（5）异步http请求线程**

* **XMLHttpRequest连接后通过浏览器新开一个线程请求；**
* **检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；**

### **浏览器输入url后的时序图**

![img](./img/26826.jpg)

## 浏览器事件机制

### 事件是什么？事件模型？

**事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。**

**事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：**

* **DOM0 级事件模型**，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。
* **IE 事件模型**，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。
* **DOM2 级事件模型**，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。

### 如何阻止事件冒泡

* **普通浏览器使用：event.stopPropagation() **
* **IE浏览器使用：event.cancelBubble = true;**

### 对事件委托的理解

**（1）事件委托的概念**

**事件委托本质上是利用了**浏览器事件冒泡**的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。

**使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。**

**（2）事件委托的特点**

* **减少内存消耗**

**如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="html" cid="n1972" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="html"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tag cm-bracket"><</span><span class="cm-tag">ul</span> <span class="cm-attribute">id</span>=<span class="cm-string">"list"</span><span class="cm-tag cm-bracket">></span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-tag cm-bracket"><</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span>item 1<span class="cm-tag cm-bracket"></</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-tag cm-bracket"><</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span>item 2<span class="cm-tag cm-bracket"></</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-tag cm-bracket"><</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span>item 3<span class="cm-tag cm-bracket"></</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  ......</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-tag cm-bracket"><</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span>item n<span class="cm-tag cm-bracket"></</span><span class="cm-tag">li</span><span class="cm-tag cm-bracket">></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tag cm-bracket"></</span><span class="cm-tag">ul</span><span class="cm-tag cm-bracket">></span></span></pre></div></div></div></div></div><div></div></div></div></pre>

**如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。**

* **动态绑定事件**

**给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="javascript" cid="n1978" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="javascript"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 给父层元素绑定事件</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">document</span>.<span class="cm-property">getElementById</span>(<span class="cm-string">'list'</span>).<span class="cm-property">addEventListener</span>(<span class="cm-string">'click'</span>, <span class="cm-keyword">function</span> (<span class="cm-def">e</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-comment">// 兼容性处理</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-keyword">var</span> <span class="cm-def">event</span> <span class="cm-operator">=</span> <span class="cm-variable-2">e</span> <span class="cm-operator">||</span> <span class="cm-variable">window</span>.<span class="cm-property">event</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-keyword">var</span> <span class="cm-def">target</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">target</span> <span class="cm-operator">||</span> <span class="cm-variable-2">event</span>.<span class="cm-property">srcElement</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-comment">// 判断是否匹配目标元素</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-keyword">if</span> (<span class="cm-variable-2">target</span>.<span class="cm-property">nodeName</span>.<span class="cm-property">toLocaleLowerCase</span> <span class="cm-operator">===</span> <span class="cm-string">'li'</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">'the content is: '</span>, <span class="cm-variable-2">target</span>.<span class="cm-property">innerHTML</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">});</span></pre></div></div></div></div></div><div></div></div></div></pre>

**在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；**

**（3）局限性**

**当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。**

**当然事件委托不是只有优点，它也是有**缺点**的，事件委托会影响页面性能，主要影响因素有：

* **元素中，绑定事件委托的次数；**
* **点击的最底层元素，到绑定事件元素之间的** `DOM`层数；

**在必须使用事件委托的地方，可以进行如下的处理：**

* **只在必须的地方，使用事件委托，比如：**`ajax`的局部刷新区域
* **尽量的减少绑定的层级，不在** `body`元素上，进行绑定
* **减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。**

### 事件委托的使用场景

**场景：给页面的所有的a标签添加click事件，代码如下：**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="javascript" cid="n2001" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="javascript"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">document</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">e</span>) {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-keyword">if</span> (<span class="cm-variable-2">e</span>.<span class="cm-property">target</span>.<span class="cm-property">nodeName</span> <span class="cm-operator">==</span> <span class="cm-string">"A"</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"a"</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">}, <span class="cm-atom">false</span>);</span></pre></div></div></div></div></div><div></div></div></div></pre>

**但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。**

**这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="javascript" cid="n2005" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="javascript"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">document</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">e</span>) {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-keyword">var</span> <span class="cm-def">node</span> <span class="cm-operator">=</span> <span class="cm-variable-2">e</span>.<span class="cm-property">target</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-keyword">while</span> (<span class="cm-variable-2">node</span>.<span class="cm-property">parentNode</span>.<span class="cm-property">nodeName</span> <span class="cm-operator">!=</span> <span class="cm-string">"BODY"</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-keyword">if</span> (<span class="cm-variable-2">node</span>.<span class="cm-property">nodeName</span> <span class="cm-operator">==</span> <span class="cm-string">"A"</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"a"</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-keyword">break</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span>}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-tab" role="presentation" cm-text="	"></span><span class="cm-variable-2">node</span> <span class="cm-operator">=</span> <span class="cm-variable-2">node</span>.<span class="cm-property">parentNode</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-tab" role="presentation" cm-text="	"></span>}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">}, <span class="cm-atom">false</span>);</span></pre></div></div></div></div></div><div></div></div></div></pre>

### 同步和异步的区别

* **同步**指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。
* **异步**指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理

### 事件触发的过程是怎样的

**事件触发有三个阶段：**

**●window 往事件触发处传播，遇到注册的捕获事件会触发**

**●传播到事件触发处时触发注册的事件**

**●从事件触发处往 window 传播，遇到注册的冒泡事件会触发**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="js" cid="n2017" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 以下会先打印冒泡然后是捕获</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">node</span>.<span class="cm-property">addEventListener</span>(</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-string">'click'</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-def">event</span> <span class="cm-operator">=></span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">'冒泡'</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  },</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-atom">false</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">node</span>.<span class="cm-property">addEventListener</span>(</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-string">'click'</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-def">event</span> <span class="cm-operator">=></span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">'捕获 '</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  },</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-atom">true</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">)</span></pre></div></div></div></div></div><div></div></div></div></pre>

**事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。**

**通常使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false ，useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：**

**●capture：布尔值，和 useCapture 作用一样**

**●once：布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听**

**●passive：布尔值，表示永远不会调用 preventDefault**

**一般来说，如果只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。**

**stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="js" cid="n2028" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="js"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">node</span>.<span class="cm-property">addEventListener</span>(</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-string">'click'</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-def">event</span> <span class="cm-operator">=></span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable-2">event</span>.<span class="cm-property">stopImmediatePropagation</span>()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">'冒泡'</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  },</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-atom">false</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">node</span>.<span class="cm-property">addEventListener</span>(</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-string">'click'</span>,</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-def">event</span> <span class="cm-operator">=></span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">'捕获 '</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  },</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">  <span class="cm-atom">true</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation">)</span></pre></div></div></div></div></div><div></div></div></div></pre>

## 浏览器缓存

### 对浏览器的缓存机制的理解

**浏览器缓存的全过程：**

* **浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；**
* **下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；**
* **如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；**
* **服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；**
* **如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；**

![img](./img/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE1.png)

**很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。**

### 协商缓存和强缓存的区别

#### （1）强缓存

**使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。**

**强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 **Expires 属性**和 **Cache-Control 属性**。

**（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。**这个时间是一个绝对时间，它是服务器的时间**，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

**（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，**

`Cache-Control`可设置的字段：

* `public`：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；
* `private`：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；
* `no-cache`：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；
* `no-store`：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；
* `max-age=`：设置缓存的最大有效期，**单位为秒**；
* `s-maxage=`：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；
* `max-stale[=]`：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。

**一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。**

**no-cache和no-store很容易混淆：**

* **no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；**
* **no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。**

#### （2）协商缓存

**如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。**

**上面已经说到了，命中协商缓存的条件有两个：**

* `max-age=xxx` 过期了
* **值为** `no-store`

**使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。**

**协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 **Etag** 和 **Last-Modified** 属性。

**（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。**

**（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。**

**当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。**

**总结：**

**强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。**

### 为什么需要浏览器缓存？

**对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。**

**所谓的**浏览器缓存**指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。

**使用浏览器缓存，有以下优点：**

* **减少了服务器的负担，提高了网站的性能**
* **加快了客户端网页的加载速度**
* **减少了多余网络数据传输**

### 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？

* **点击刷新按钮或者按 F5：**浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。
* **用户按 Ctrl+F5（强制刷新）：**浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。
* **地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。**

## 浏览器安全

### XSS 攻击

#### （1）概念

**XSS 攻击指的是**跨站脚本攻击**，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

**XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。**

**攻击者可以通过这种攻击方式可以进行以下操作：**

* **获取页面的数据，如DOM、cookie、localStorage；**
* **DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；**
* **破坏页面结构；**
* **流量劫持（将链接指向某网站）；**

#### （2）攻击类型

**XSS 可以分为存储型、反射型和 DOM 型：**

* **存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。**
* **反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 **
* **DOM 型指的通过修改页面的 DOM 节点形成的 XSS。**

**1）存储型 XSS 的攻击步骤：**

1. **攻击者将恶意代码提交到⽬标⽹站的数据库中。 **
2. **⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 **
3. **⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 **
4. **恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。 **

**这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。**

**2）反射型 XSS的攻击步骤：**

1. **攻击者构造出特殊的 URL，其中包含恶意代码。 **
2. **⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 **
3. **⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 **
4. **恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。 **

**反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。 **

**反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。  **

**3）DOM 型 XSS的攻击步骤：**

1. **攻击者构造出特殊的 URL，其中包含恶意代码。 **
2. **⽤户打开带有恶意代码的 URL。 **
3. **⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。 **
4. **恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。 **

**DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。 **

### 如何防御 XSS 攻击？

**可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：**

* **可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。**
* **使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。**

1. **CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。**
2. **通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 **`<meta http-equiv="Content-Security-Policy">`

* **对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。**

### CSRF 攻击

#### （1）概念

**CSRF 攻击指的是**跨站请求伪造攻击**，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

**CSRF 攻击的**本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。**

#### （2）攻击类型

**常见的 CSRF 攻击有三种：**

* **GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。**
* **POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。**
* **链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。**

### 如何防御 CSRF 攻击

**CSRF 攻击可以使用以下方法来防护：**

* **进行同源检测**，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）
* **使用 CSRF Token 进行验证**，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。
* **对**Cookie 进行双重验证**，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。
* **在设置 cookie 属性的时候设置**Samesite**，限制 cookie 不能作为被第三方使用**，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。

### 什么是中间人攻击？如何防范中间人攻击

**中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。**

**攻击过程如下: **

* **客户端发送请求到服务端，请求被中间⼈截获 **
* **服务器向客户端发送公钥 **
* **中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个**伪造的**公钥，发给客户端
* **客户端收到伪造的公钥后，⽣成加密hash值发给服务器 **
* **中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器 **
* **服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端 **
* 

### 有哪些可能引起前端安全的问题

* **跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等； **
* **iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；**
* **跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击 **
* **恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。**

### 网络劫持有哪几种，如何防范？

**⽹络劫持分为两种: **

**（1）**DNS劫持**: (输⼊京东被强制跳转到淘宝这就属于dns劫持)

* **DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器**
* **302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容 **

**（2）**HTTP劫持**: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)

**DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。**

### DOS（拒绝服务）攻击和DDoS（分布式拒绝服务）攻击

**核心目标都是通过耗尽目标系统的资源（如带宽、CPU、内存），使其无法为合法用户提供服务。它们的**主要区别在于攻击来源的数量和分布方式**：

1. **DOS 攻击（Denial-of-Service，拒绝服务攻击）**

* **攻击来源：** 单台计算机或少量设备（通常由一个攻击者直接控制）。
* **攻击方式：**
  * **利用目标系统的漏洞（如缓冲区溢出）使其崩溃。**
  * **发送大量看似合法的请求（如HTTP请求）耗尽服务器资源（如SYN洪水攻击）。**
* **特点：**
  * **相对容易实施（技术门槛较低）。**
  * **相对容易防御和追踪：由于流量来自单一或少数据源，目标管理员可以通过防火墙规则（如屏蔽攻击源IP）或修复漏洞来缓解攻击。**
  * **攻击规模有限：单台机器的带宽和处理能力有限。**
* **比喻：** 一个人不停地用力敲打你家的大门，让你无法正常开门接待其他客人。

2. **DDoS 攻击（Distributed Denial-of-Service，分布式拒绝服务攻击）**

* **攻击来源：** 数量庞大的受控设备组成的“僵尸网络”（Botnet），分布在全球各地。这些设备通常是感染了恶意软件的普通用户电脑、服务器、IoT设备（如摄像头、路由器）。
* **攻击方式：**
  * **直接攻击：** 僵尸网络中的所有设备直接向目标发送大量流量（如HTTP请求、UDP数据包）。
  * **反射/放大攻击：** 攻击者伪造目标IP地址，向大量第三方服务器（如DNS服务器、NTP服务器）发送请求。这些服务器会将大得多的响应发送回目标地址，放大攻击流量（如DNS放大攻击、NTP放大攻击）。
* **特点：**
  * **规模巨大：** 成百上千甚至数百万台设备同时发动攻击，产生远超任何单点防御能力的海量流量（可达Tbps级别）。
  * **难以防御：**
    * **攻击源IP数量庞大且分散，难以通过简单IP屏蔽阻止。**
    * **流量可能看起来像正常流量，难以精确过滤。**
    * **需要部署专业的DDoS防护服务（如云清洗中心）。**
  * **难以追踪：** 攻击者隐藏在僵尸网络背后，通过多层代理或控制服务器指挥攻击，溯源困难。
  * **危害巨大：** 可导致大型网站、在线服务、网络基础设施瘫痪，造成严重经济损失和声誉损害。
* **比喻：** 成千上万个被遥控指挥的人（僵尸网络）从四面八方同时涌向你家的门、窗、烟囱，用各种方式堵塞所有入口，让你完全无法动弹，也无法接待任何正常访客。或者，攻击者遥控一大群人（僵尸网络）冒充你家地址，向邮局订购大量重物（反射服务器），导致邮局把堆积如山的包裹（放大流量）都送到你家门口把你淹没。

**关键区别总结**

| **特性**     | **DOS 攻击**                        | **DDoS 攻击**                                |
| ------------------ | ----------------------------------------- | -------------------------------------------------- |
| **攻击源**   | **单一或少数据源**（1台或几台设备） | **海量分布式来源**（庞大僵尸网络）           |
| **攻击规模** | **相对较小**（受限于单点能力）      | **极其巨大**（Tbps级别，远超单点防御能力）   |
| **复杂性**   | **相对简单**                        | **非常复杂（需要构建/控制僵尸网络）**        |
| **防御难度** | **相对容易**（可屏蔽源头IP）        | **极其困难**（需专业防护，源头多且伪装性强） |
| **追踪难度** | **相对容易**                        | **非常困难（攻击者隐藏深）**                 |
| **危害程度** | **较小（影响范围有限）**            | **巨大（可瘫痪大型服务、基础设施）**         |
| **主导者**   | **单个攻击者**                      | **攻击者控制僵尸网络指挥中心（C&C）**        |

**为什么 DDoS 成为主流？**

* **防御技术的进步：** 基本的DOS攻击容易被现代防火墙、入侵检测系统和网络基础设施过滤掉。
* **僵尸网络的易得性：** 攻击者可以租用现成的庞大僵尸网络（即“攻击即服务”）。
* **攻击效果显著：** DDoS能产生毁灭性的流量，对大型目标也有效。
* **匿名性：** 僵尸网络提供了更好的匿名性。

**如何防御？**

* **DOS防御：** 防火墙规则、系统/应用漏洞修补、入侵检测/防御系统（IDS/IPS）、流量限速。
* **DDoS防御：**
  * **本地设备：** 部署专业的DDoS防护硬件/软件（常能力有限）。
  * **云端清洗：** 将流量路由到云服务商（如Cloudflare, Akamai, AWS Shield, 阿里云盾）的清洗中心，过滤恶意流量后再将干净流量传回目标。这是当前最主流有效的方式。
  * **带宽冗余：** 增加带宽以吸收部分攻击（成本高，对超大攻击无效）。
  * **架构设计：** 分布式架构、负载均衡、CDN等可增强韧性。

**总而言之，DDoS 是 DOS 的升级版和主流形态，利用僵尸网络的分布式特性发动规模更大、更难防御和追踪的拒绝服务攻击。** DOS 在当今环境下已较少见且相对容易防御，而防御大规模 DDoS 攻击是现代网络安全的重要挑战，通常需要借助专业的第三方防护服务。

## 浏览器本地存储

### 1. 浏览器本地存储方式及使用场景

#### （1）Cookie

**Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。**

**Cookie的特性：**

* **Cookie一旦创建成功，名称就无法修改**
* **Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie**
* **每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb**
* **有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的**
* **Cookie在请求一个新的页面的时候都会被发送过去**

**如果需要域名之间跨域共享Cookie，有两种方法：**

1. **使用Nginx反向代理**
2. **在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId**

**Cookie的使用场景：**

* **最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。**
* **可以用来统计页面的点击次数**

#### （2）LocalStorage

**LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。**

**LocalStorage的优点：**

* **在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息**
* **LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在**
* **仅储存在本地，不像Cookie那样每次HTTP请求都会被携带**

**LocalStorage的缺点：**

* **存在浏览器兼容问题，IE8以下版本的浏览器不支持**
* **如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage**
* **LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问**

**LocalStorage的常用API：**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="javascript" cid="n2459" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="javascript"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 保存数据到 localStorage</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">localStorage</span>.<span class="cm-property">setItem</span>(<span class="cm-string">'key'</span>, <span class="cm-string">'value'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 从 localStorage 获取数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">let</span> <span class="cm-def">data</span> <span class="cm-operator">=</span> <span class="cm-variable">localStorage</span>.<span class="cm-property">getItem</span>(<span class="cm-string">'key'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 从 localStorage 删除保存的数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">localStorage</span>.<span class="cm-property">removeItem</span>(<span class="cm-string">'key'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 从 localStorage 删除所有保存的数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">localStorage</span>.<span class="cm-property">clear</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 获取某个索引的Key</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">localStorage</span>.<span class="cm-property">key</span>(<span class="cm-variable">index</span>)</span></pre></div></div></div></div></div><div></div></div></div></pre>

**LocalStorage的**使用场景：**

* **有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可**
* **在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中**

#### （3）SessionStorage

**SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。**

**SessionStorage与LocalStorage对比**

* **SessionStorage和LocalStorage都在**本地进行数据存储**；
* **SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage**只有在同一浏览器的同一窗口下才能够共享**；
* **LocalStorage和SessionStorage**都不能被爬虫爬取**；

**SessionStorage的常用API：**

<pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="javascript" cid="n2479" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="javascript"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 保存数据到 sessionStorage</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">sessionStorage</span>.<span class="cm-property">setItem</span>(<span class="cm-string">'key'</span>, <span class="cm-string">'value'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 从 sessionStorage 获取数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-keyword">let</span> <span class="cm-def">data</span> <span class="cm-operator">=</span> <span class="cm-variable">sessionStorage</span>.<span class="cm-property">getItem</span>(<span class="cm-string">'key'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 从 sessionStorage 删除保存的数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">sessionStorage</span>.<span class="cm-property">removeItem</span>(<span class="cm-string">'key'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 从 sessionStorage 删除所有保存的数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">sessionStorage</span>.<span class="cm-property">clear</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span cm-text="" cm-zwsp=""></span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-comment">// 获取某个索引的Key</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-variable">sessionStorage</span>.<span class="cm-property">key</span>(<span class="cm-variable">index</span>)</span></pre></div></div></div></div></div><div></div></div></div></pre>

**SessionStorage的使用场景**

* **由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。**

### 2. Cookie有哪些字段，作用分别是什么

**Cookie由以下字段组成：**

* **Name**：cookie的名称
* **Value**：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；
* **Size**： cookie的大小
* **Path**：可以访问此cookie的页面路径。 比如domain是abc.com，path是 `/test`，那么只有 `/test`路径下的页面可以读取此cookie。
* **Secure**： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。
* **Domain**：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。
* **HTTP**： 该字段包含 `HTTPOnly` 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过 `document.cookie`属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。
* **Expires/Max-size** ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。
* `SameSite` 是 Cookie 的一个属性，通过 **`Set-Cookie` 响应头** 由服务器发送给浏览器。语法如下：
  <pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" contenteditable="true" lang="http" cid="n2505" mdtype="fences"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="http"><div><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer"><div><div class="CodeMirror-lines" role="presentation"><div role="presentation"><div class="CodeMirror-measure"><pre><span></span></pre></div><div class="CodeMirror-measure"></div><div></div><div class="CodeMirror-cursors"><div class="CodeMirror-cursor"></div></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation"><span class="cm-error">Set-Cookie: cookieName=value; SameSite=None|Lax|Strict; Secure; Domain=example.com; Path=/</span></span></pre></div></div></div></div></div></div><div></div></div></div></pre>

**		**控制浏览器是否在跨站请求中发送 Cookie，防止 CSRF 攻击。

**总结：**

**服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。**

**cookie跨域携带**

| **要求**        | **客户端**           | **服务器端**                                        |
| --------------------- | -------------------------- | --------------------------------------------------------- |
| **凭证传递**    | `credentials: 'include'` | `Access-Control-Allow-Credentials: true`                |
| **域名限制**    | **-**                | `Access-Control-Allow-Origin`需明确指定域名（非 `*`） |
| **Cookie 属性** | **-**                | `SameSite=None; Secure`必须同时设置                     |
| **协议要求**    | **必须 HTTPS**       | **必须 HTTPS**                                      |

### 3. Cookie、LocalStorage、SessionStorage区别

**浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。**

* **cookie：**其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。
* **sessionStorage：**html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。
* **localStorage：**html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。

**上面三种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。**

**Web Storage 和 cookie 的区别总结如下：**

* **Web Storage是为了更大容量存储设计的。Cookie 的大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中浪费了带宽；**
* **cookie 需要指定作用域，不可以跨域调用；**
* **Web Storage 拥有 setItem,getItem,removeItem,clear 等方法，不像 cookie 需要前端开发者自己封装 setCookie，getCookie；**
* **Cookie 也是不可以或缺的：Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生。**

### 4. 前端储存的⽅式有哪些？

* **cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；**
* **localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；**
* **sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式； **
* **Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐； **
* **IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。 **

### 5. IndexedDB有哪些特点？

**IndexedDB 具有以下特点：**

* **键值对储存**：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。
* **异步**：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。
* **支持事务**：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
* **同源限制：**IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。
* **储存空间大**：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。
* **支持二进制储存**：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。
